# -*- coding: utf-8 -*-
"""02249-ComputationallyHardProblems_assignement1_v3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vsCDP0oGglR5Mo6TFCGz0dQRvlMqBtCM


"""

import math
import networkx as nx
import numpy as np
import matplotlib.pyplot as plt
import statistics
from statistics import mean
from matplotlib import pyplot
from itertools import combinations
import copy
from sympy import *
import math
import os
import sys
from google.colab import files

import timeit
from timeit import default_timer as timer
#dash = '-'*50


"""# Ancillary Functions

## create random connected graph
with random weights, usefull for testing
"""

def random_connected_graph(n=5,p=0.6,this_seed= None, draw_statement = True, l= 5,h=5, weight_low = 1, weight_high = 10):
  """
  randG = random_connected_graph(n=5,p=0.6,this_seed= None, draw_statement = True, l= 5,h=5)
  creates and draws a random graph
  n  number of vertices
  p  connecting probability
  l,h dimension of draw graph
  """
  G = nx.erdos_renyi_graph(n, p, seed=this_seed, directed=False)

  #verify it is connected
  #print ("graph is connected: ",nx.is_connected(G))
  connected_stat = nx.is_connected(G)
  #add random weights
  for edge in list(G.edges):
    u = edge[0]
    v = edge[1]
    weight = np.random.randint(weight_low,weight_high) # weight is randomly choosen between 1-9
    G[u][v]['weight'] = weight
  if draw_statement == True:
    draw(G,l,h)
  return G, connected_stat

"""## Create dictionary of weights"""

def weights_dict_and_list(G):
  """
  E_weights,E_weights_list = weights_dict_and_list(G)
  eg
  E_weights
  E_weights_list
  """
  E_weights = dict()
  for edge in G.edges():
    this = G.get_edge_data(edge[0],edge[1])
    E_weights[edge]= (this['weight'])

  E_weights_list = list(E_weights.values())
  return E_weights,E_weights_list

"""## Draw Graph with some custom settings"""

def draw(G,length=10, heigth=10):
  """
  draw(G)
  """
  E_weights,E_weights_list = weights_dict_and_list(G)
  if max(E_weights_list)>10:
    conversion = 0.1
  else: conversion = 1

  print_widths = [i*conversion for i in E_weights_list]

  pos = nx.spring_layout(G) #positioning of the graph
  plt.figure(figsize=(length, heigth))
  plt.title("sum of weights : %s"%(sum(E_weights_list)))
  nx.draw(G,pos, with_labels=True, width=print_widths)
  nx.draw_networkx_edge_labels(G,pos = pos, edge_labels=E_weights, label_pos=0.2, font_size=15,font_color='black',alpha = 0.9)

"""## dictionaries of edges and their mirror - keeping the order given by the input

networkx maintains the order of the nodes but not of the edges, therefore... mapping while the stdin is read.
"""

def dict_edges_mirror2(mapping_edges_indexes):
  """
  e_m = dict_edges_mirror(mapping_edges_indexes)

  e_m eg
  (1, 2, 1): (1, 3, 3)

  """
  start = timer()
  e_m = dict()
  m = len(mapping_edges_indexes.keys())
  half_way = round((m+1)/2)
  for i in range(1,half_way):
    this_e = mapping_edges_indexes[i]
    mirror_e = mapping_edges_indexes[m+1-i]
    if not (this_e) in e_m.keys():
        e_m[this_e] = mirror_e
        e_m[mirror_e] = this_e
  end = timer()
  print("computational time: ",end-start)
  return e_m

def dict_edges_mirror(mapping_edges_indexes):
  """
  e_m = dict_edges_mirror(mapping_edges_indexes)

  e_m eg
  (1, 2, 1): (1, 3, 3)

  """
  start = timer()
  e_m = dict()
  m = len(mapping_edges_indexes.keys())
  for i in range(1,m+1):
    this_e = mapping_edges_indexes[i]
    mirror_e = mapping_edges_indexes[m+1-i]
    if not (this_e) in e_m.keys():
        e_m[this_e] = mirror_e
  end = timer()
  print("computational time: ",end-start)
  return e_m

"""## check completeness

TODO: check which one is more efficient
"""

# using this one currently
def is_graph_complete(G):
  """
  returns True if each element in the graph has a degree equal to the number of nodes -1
  """
  return all(element == nx.number_of_nodes(G)-1 for element in list(dict(G.degree).values()))

def is_complete(G):
    n = G.order()
    return n*(n-1)/2 == G.size()

"""## cofactor of a matrix (efficient)"""

def matrix_cofactor(matrix):
    return np.linalg.inv(matrix).T * np.linalg.det(matrix)

"""## compute the minor of a matrix M"""

def minor(M, i, j):
    M = np.delete(M, i, 0)
    M = np.delete(M, j, 1)
    return M

"""##n choose k"""

def n_choose_k(n, k):
    return math.factorial(n) // math.factorial(k) // math.factorial(n - k)

"""## create a random string of bits"""

def rand_bin_array(K, N):
  """
  arr = rand_bin_array(K, N)
  """
  arr = np.zeros(N)
  arr[:K]  = 1
  np.random.shuffle(arr)
  return arr

"""## flatten edges"""

def flatten_edges_with_weights(edges):
  """
  edges = G.edges.data()
  input is a G.edge = u,v,w['weight']
  output is a Tuple = (u,v,w)
  """
  #return [(x[0],x[1],x[2]['weight'] )for x in list(edges)]
  flat_edges = []
  for x in list(edges):
      if x[0] < x[1]:
          u,v = x[0],x[1]
      else:
          u,v = x[1],x[0]
      flat_edges.append((u,v,x[2]['weight'] ))
  return flat_edges

"""## create new edges which are sum edges with their mirror
new_edge_i = e_i + e_m+1-i
"""

# sum edges with their mirror
def sum_with_mirror_edges(edges, e_m):
  """
  new_edges,new_edges_dict = sum_with_mirror_edges(edges)
  """
  #new_edges_dict= copy.deepcopy(edges)
  new_edges = []
  for edge in list(e_m.keys()):
    print (edge, e_m[edge])
    #print (e_m[i][2]['weight'])
    u,v,w = edge
    u_m,v_m,w_m = e_m[edge]
    new_weight = w + w_m
    difference_weight = (w-w_m)
    print (new_weight,difference_weight, new_weight*difference_weight)
    #new_edges_dict[i]= new_weight
    new_edges.append((u,v,new_weight*difference_weight))
  return new_edges#,new_edges_dict

"""## Exploratory random"""

def exploratory_random (B,G,R,e_m,mapping_edges_indexes, list_edges,num_trials = 10):
  """
  one_rand_timer = exploratory_random (G,R,e_m,mapping_edges_indexes, list_edges,num_trials = 10)
  """
  for i in range(num_trials):
    R = rand_bin_array(k, m) #R0
    #subgraph,subgraph_mirror= check_ST(G,R,e_m, list_edges,print_statement = False)
    subgraph,subgraph_mirror= build_T_Tmirror(G,R,e_m,mapping_edges_indexes, list_edges,print_statement = False)
    if subgraph.number_of_nodes() > 0:
      max_value,sum_T,sum_mirror =  max_and_plot_sG_sGmirror(subgraph,subgraph_mirror,plot_statement = False)
      if max_value <= B:
        B = max_value
        Best_couple = (subgraph,subgraph_mirror)
        #print ("found a smaller B: ",B)
  one_rand_timer = (end - start)/num_trials
  return one_rand_timer

"""## max trials random"""

def max_trials_random (B,G,R,e_m,mapping_edges_indexes, list_edges,num_trials):
  """
  B, Best_couple = max_trials_random (G,R,e_m,mapping_edges_indexes, list_edges,num_trials = 10)
  """
  num_trials
  for i in range(num_trials):
    R = rand_bin_array(k, m) #R0
    #subgraph,subgraph_mirror= check_ST(G,R,e_m, list_edges,print_statement = False)
    subgraph,subgraph_mirror= build_T_Tmirror(G,R,e_m,mapping_edges_indexes, list_edges,print_statement = False)
    if subgraph.number_of_nodes() > 0:
      max_value,sum_T,sum_mirror =  max_and_plot_sG_sGmirror(subgraph,subgraph_mirror,plot_statement = False)
      if max_value <= B:
        B = max_value
        Best_couple = (subgraph,subgraph_mirror)

  return B, Best_couple

"""# Main Functions

## Build spanning Tree from Random String R0
- read random input
- select edges
- if tree find mirror
- returns tree and its mirror as Graphs
"""

def build_T_Tmirror(G,R,e_m, mapping_edges_indexes,list_edges,print_statement = False):
  """
  sG,sG_mirror= build_T_Tmirror(G,R,e_m, mapping_edges_indexes, list_edges,print_statement = True)
  """

  # create selected_edges from R0
  selected_edges = []
  for i in range(len(R)):
    if R[i] == 0:
      continue
    else:
      selected_edges.append(mapping_edges_indexes[i+1])

  #create a set of vertices from the selected edges
  selected_edges_noweights = [x[:2] for x in selected_edges]
  all_edges_flat = [element for tupl in selected_edges_noweights for element in tupl]
  selected_nodes = set(all_edges_flat)
  #print (selected_nodes)
  sG = G.edge_subgraph(selected_edges_noweights)

  # if the combination gives a spanning tree
  if len(selected_nodes) == len(G.nodes()) and nx.is_connected(sG):
    try: # search for cycles
      nx.find_cycle(sG)
    except:#if none continue
      #create the mirror
      mirror_edges = []
      for edge in selected_edges:
        mirror_edge = e_m[(edge[0],edge[1],edge[2])]
        mirror_edge_noweights =  mirror_edge[:2]
        mirror_edges.append(mirror_edge_noweights)

      # add the tree and his mirror to a list
      if print_statement == True:
        print ("")
        print ("graph edges: ",[(u,v) for (u,v,w) in list_edges])
        print ("random bin sequence",R)
        print ("selected_edges: ",selected_edges_noweights)
        print ("mirror_edges: ",mirror_edges)

      sG = G.edge_subgraph(selected_edges_noweights)
      sG_mirror = G.edge_subgraph(mirror_edges)
      return sG,sG_mirror
  else:
    if print_statement == True:
      print ("the edges selected with R0 are not a spanning tree")
    return nx.Graph(),nx.Graph()

"""## All spanning trees and mirrors - exhaustive search"""

def all_spanningtrees_mirrors(G,e_m, print_statement = False):
  """
  all_spanning_trees,all_mirror_trees,delta= all_spanningtrees_mirrors(G,e_m, print_statement = True)

  """

  start = timer()
  all_spanning_trees = []
  all_mirror_trees = []
  num_v = len(G.nodes())

  combos = list(combinations(G.edges.data(),num_v-1))
  #cc = 0
  counter = 0
  rej_counter =0
  #possible_counter = 0
  #print (len(combos[:2]))
  if print_statement == True:
    print ("there are in total %s possible combination that could give spanning trees" %len(combos))
    print ("calculating spanning trees of lenght %s for G with %s nodes"%(num_v-1,num_v))

  for selected_edges in (combos):
    #cc +=1
    #print(selected_edges)
    selected_edges_noweights = [x[:2] for x in selected_edges]
    all_edges_flat = [element for tupl in selected_edges_noweights for element in tupl]
    selected_nodes = set(all_edges_flat)
    #print (selected_nodes)
    sG = G.edge_subgraph(selected_edges_noweights)

    # if the combination gives a spanning tree
    if len(selected_nodes) == len(G.nodes()) and nx.is_connected(sG):
      #possible_counter +=1
      try: # search for cycles
        nx.find_cycle(sG)
      except:#if none continue
        counter +=1
        mirror_edges = []
        for edge in selected_edges:
          if edge[0]< edge[1]:
            u,v = edge[0], edge[1]
          else:
            u,v = edge[1],edge[0],
          mirror_edge = e_m[(u,v,edge[2]['weight'])]
          mirror_edge_noweights =  mirror_edge[:2]
          mirror_edges.append(mirror_edge_noweights)

        # add the tree and his mirror to a list
        if print_statement == "mirror_details":
          print ("")
          print ("edges: ",selected_edges_noweights)
          print ("mirror_edges: ",mirror_edges)

        sG = G.edge_subgraph(selected_edges_noweights)
        sG_mirror = G.edge_subgraph(mirror_edges)
        all_spanning_trees.append(sG)
        all_mirror_trees.append(sG_mirror)
      else:
        rej_counter +=1
        continue
    else:
      rej_counter +=1
      continue
  end = timer()
  delta = end-start
  if print_statement == True:
    print ("%s spanning trees found" %(len(all_spanning_trees)))
    print ("%s selected edges excluded " %(rej_counter))
    print ("time required for computation : ",delta)
  return all_spanning_trees,all_mirror_trees,delta

"""## Calculate exact solution, by exhaustive search"""

def calculate_exact_solution(all_spanning_trees, all_mirror_trees, plot_statement= True): #old plot_trees_mirrors
  """
  B_upper,subgraph,subgraph_mirror, delta_time = calculate_exact_solution(all_spanning_trees, all_mirror_trees, plot_statement= True)

  """
  B_upper,sum_T,sum_mirror = 100000000,0,0
  start = timer()
  for i in range(len(all_spanning_trees)):
    sG = all_spanning_trees[i] # this tree
    sG_mirror = all_mirror_trees[i]  #its mirror

    this_max_value,this_sum_T,this_sum_mirror =  max_and_plot_sG_sGmirror(sG,sG_mirror,plot_statement) # returns the max(this_sum_t,this_sum_mirror)
    #print (i, this_max_value, B_upper)
    if this_max_value <= B_upper:
      B_upper,subgraph,subgraph_mirror = this_max_value,sG,sG_mirror
      #print ("updated B")
      #max_value = this_max_value

  end = timer()
  delta_time = end - start
  return B_upper,subgraph,subgraph_mirror, delta_time

"""## Plot one tree and its mirror"""

def max_and_plot_sG_sGmirror(subgraph,subgraph_mirror,plot_statement = True):
  """
  B_upper,sum_T,sum_mirror =  max_and_plot_sG_sGmirror(subgraph,subgraph_mirror,plot_statement = True)
  """
  subgraph_E_weights,subgraph_E_weights_list = weights_dict_and_list(subgraph)
  subgraph_mirror_E_weights,subgraph_mirror_E_weights_list = weights_dict_and_list(subgraph_mirror)

  sum_T = sum(subgraph_E_weights_list)
  sum_mirror = sum(subgraph_mirror_E_weights_list)
  B_upper = max (sum_T,sum_mirror)

  if max(subgraph_E_weights_list)>10:
    conversion = 0.1
  else: conversion = 1

  print_widths_T = [i*conversion for i in subgraph_E_weights_list]
  print_widths_T_mirror = [i*conversion for i in subgraph_mirror_E_weights_list]


  if plot_statement == True:
    # plot graphs
    plt.figure(figsize=(12, 10))
    plt.subplot(2, 2, 1)
    plt.title ("G spanning tree, m = %s, sum = %s" %(len(subgraph.edges()),sum_T ))
    pos = nx.spring_layout(subgraph) #positioning of the graph
    nx.draw(subgraph,pos, with_labels=True, width=print_widths_T )
    nx.draw_networkx_edge_labels(subgraph,pos = pos, edge_labels=subgraph_E_weights, label_pos=0.5, font_size=15,font_color='black')

    plt.subplot(2, 2, 2)
    plt.title ("mirror of G spanning tree, m = %s, sum = %s" %(len(subgraph_mirror.edges()),sum_mirror ))
    pos = nx.spring_layout(subgraph_mirror) #positioning of the graph
    nx.draw(subgraph_mirror,pos, with_labels=True, width=print_widths_T_mirror)
    nx.draw_networkx_edge_labels(subgraph_mirror,pos = pos, edge_labels=subgraph_mirror_E_weights, label_pos=0.5, font_size=15,font_color='black')

  return B_upper,sum_T,sum_mirror

"""## TO DO check size of the problem and adopt different strategies

- if num edges less than K1 then do complete strategy
- if input > K1 then do best strategy
- (if num edges more than K2 then do random? )

## heuristics
notes from meeting tuesday 20-10-2020

- include edegs in the graph -->  the ones without the graph wouldnt be connected
- calculating T and T_mirror
- calculating first T and first T_mirror, calculate next spanning T and if bigger or equal then previous discard
- calculating T, list by weight. start from the smallest group, check mirrors. if T_mirror == T we are done. reiterate.

## EDGES SELECTION

### find Must-have edges

function that given a graph, finds which edges MUST be in the spanning tree.
how?
linear search: take one edge out at the time, is the graph still connected?

if YES --> continue

if NO --> add to the pool of mandatory edges,


once the list of mandatory edges is created, pick the possible combinations of trees by choosing rondomly the remaining edges.

time complexity: O(m)+time to create the graph with reduced edges + time to check that the graph is not connected = O(m+n)
"""

def find_musthave_edges(G):
    """
    must_have_edges,all_edges = find_musthave_edges(G)
    both lists in form: [(u,v,'weight')...]


    """

    edges = list(G.edges.data())
    must_have_list = list(nx.bridges(G)) # bridges returns only the nodes (u,v)
    must_have_edges = []
    for (u,v) in must_have_list:
      if u <v:
        edge = (u,v,(G[u][v]))
      else:
        edge = (v,u,(G[u][v]))
      must_have_edges.append(edge)

    all_edges= []
    for (u,v,w) in edges: # each edge is (u,v,w['weight'])
      if u <v:
        edge = (u,v,w)
      else:
        edge = (v,u,w)
      all_edges.append(edge)


    return must_have_edges,all_edges

## is io nx.bridges(G)
# https://networkx.org/documentation/stable/reference/algorithms/generated/networkx.algorithms.bridges.bridges.html
# time complexity for G = (Vn,Em) O(n+m)

"""### Fewer spanning trees and mirrors - still exhaustive search

with less options
"""

def fewer_spanningtrees_mirrors(G,e_m, print_statement = False):
  """
  fewer_spanning_trees,all_mirror_trees,delta= fewer_spanningtrees_mirrors(G,e_m, print_statement = True)

  """
  start = timer()
  all_spanning_trees = []
  all_mirror_trees = []
  num_v = len(G.nodes())

  must_have_edges,all_edges_list = find_musthave_edges(G) #edges that will be in tree for sure
  num_missing_edges = (n-1)-len(must_have_edges)# n is the number of nodes, n-1 is the number of edges in a spanning tree

  if print_statement == True:
    print ("found %s must-have edges out of %s of the tree" %(len(must_have_edges),n-1))

  # if the must have edges are already all the edges that we need for the spanning tree
  #solution found
  if num_missing_edges == 0: # extreme case that a graph is already a spanning tree
    all_spanning_trees.append(G)
    all_mirror_trees.append(G)

  # we need to pick the difference from the remaining unchoosen edges, "random_edges"
  else:
    random_edges = [item for item in all_edges_list if item not in must_have_edges]
    #random_edges = list((set(all_edges_list)-set(must_have_edges))) #bunch of edges to choose from
    all_missing_combo = list(combinations(random_edges,num_missing_edges))

    combos = []
    counter = 0
    rej_counter =0
    if print_statement == True:
      print ("there are in total %s possible combination that could give spanning trees" %len(all_missing_combo))
      print ("calculating spanning trees of lenght %s for G with %s nodes"%(num_v-1,num_v))

    for i in range(len(all_missing_combo)):
      selected_edges = must_have_edges + list(all_missing_combo[i]) # create ONE list with all the edges

      selected_edges_noweights = [x[:2] for x in selected_edges]
      all_edges_flat = [element for tupl in selected_edges_noweights for element in tupl]
      selected_nodes = set(all_edges_flat)

      sG = G.edge_subgraph(selected_edges_noweights)

      # if the combination gives a spanning tree
      if len(selected_nodes) == len(G.nodes()) and nx.is_connected(sG):

        try: # search for cycles
          nx.find_cycle(sG)
        except:#if none continue
          counter +=1
          mirror_edges = []
          for edge in selected_edges:
            if edge[0]< edge[1]: # in the dictionary e_m the first node is always the smallest
              u,v = edge[0], edge[1]
            else:
              u,v = edge[1],edge[0],
            mirror_edge = e_m[(u,v,edge[2]['weight'])]
            mirror_edge_noweights =  mirror_edge[:2]
            mirror_edges.append(mirror_edge_noweights)

          # add the tree and his mirror to a list
          if print_statement == "mirror_details":
            print ("")
            print ("edges: ",selected_edges_noweights)
            print ("mirror_edges: ",mirror_edges)

          #sG = G.edge_subgraph(selected_edges_noweights)
          sG_mirror = G.edge_subgraph(mirror_edges)
          all_spanning_trees.append(sG)
          all_mirror_trees.append(sG_mirror)
        else:
          rej_counter +=1
          continue
      else:
        rej_counter +=1
        continue
  end = timer()
  delta = end - start
  if print_statement == True:
    print ("%s spanning trees found" %(len(all_spanning_trees)))
    print ("%s selected edges excluded " %(rej_counter))
    print ("time required for computation of fewer_spanningtrees_mirrors : ",delta)
  return all_spanning_trees,all_mirror_trees,delta

"""## PRUNING 1

1) calculate one tree and one mirror, get B as max of the two.

2) calculate next tree and its B, if more then previous --> skip, otherwise 1)
"""

def pruning_one(G,e_m, print_statement = False):
  """
  B_upper,one_spanning_tree, one_mirror_tree,delta_time = pruning_one(G,e_m, print_statement = True)

  """
  start = timer()
  num_v = len(G.nodes())
  must_have_edges,all_edges_list = find_musthave_edges(G) #edges that will be in tree for sure
  #print (must_have_edges)
  num_missing_edges = (n-1)-len(must_have_edges)# n is the number of nodes, n-1 is the number of edges in a spanning tree
  E_weights,E_weights_list = weights_dict_and_list(G)
  B_upper = sum(E_weights_list)

  if print_statement == True:
    print ("found %s must-have edges out of %s of the tree" %(len(must_have_edges),n-1))
    print ("total sum of weights for G: ",B_upper)

  # if the must have edges are already all the edges that we need for the spanning tree
  if num_missing_edges == 0: # extreme case that a graph is already a spanning tree
    one_spanning_tree, one_mirror_tree = G,G

  # we need to pick the difference from the remaining unchoosen edges, "random_edges"
  else:
    random_edges = [item for item in all_edges_list if item not in must_have_edges]
    all_missing_combo = list(combinations(random_edges,num_missing_edges))
    combos = []

    if print_statement == True:
      print ("there are in total %s possible combination that could give spanning trees" %len(all_missing_combo))
      print ("calculating spanning trees of lenght %s for G with %s nodes"%(num_v-1,num_v))

    for i in range(len(all_missing_combo)):
      selected_edges = must_have_edges + list(all_missing_combo[i]) # create ONE list with all the edges
      selected_edges_noweights = [x[:2] for x in selected_edges]
      all_edges_flat = [element for tupl in selected_edges_noweights for element in tupl]
      selected_nodes = set(all_edges_flat)
      sG = G.edge_subgraph(selected_edges_noweights)

      # if the combination gives a spanning tree
      if len(selected_nodes) == len(G.nodes()) and nx.is_connected(sG) :
        try: # search for cycles
          nx.find_cycle(sG) # continues after the else line 77
        except: #if it is a proper spanning tree

          #sum its edges weights
          sG_E_weights,sG_E_weights_list = weights_dict_and_list(sG)
          sum_T = sum(sG_E_weights_list)

          #print ("B_upper: %s; current sum: %s" %(B_upper,sum_T))
          if sum_T >= B_upper:
            continue
          else:
            mirror_edges = []
            for edge in selected_edges:
              if edge[0]< edge[1]:
                u,v = edge[0], edge[1]
              else:
                u,v = edge[1],edge[0],
              mirror_edge = e_m[(u,v,edge[2]['weight'])]
              mirror_edge_noweights =  mirror_edge[:2]
              mirror_edges.append(mirror_edge_noweights)

            # add the tree and his mirror to a list
            if print_statement == "True":
              print ("")
              print ("edges: ",selected_edges_noweights)
              print ("mirror_edges: ",mirror_edges)

            #sG = G.edge_subgraph(selected_edges_noweights)
            sG_mirror = G.edge_subgraph(mirror_edges)

            #calculate sum of weights sG_mirror
            sG_mirror_E_weights,sG_mirror_E_weights_list = weights_dict_and_list(sG_mirror)
            sum_T_mirror= sum(sG_mirror_E_weights_list)
            max_value = max(sum_T, sum_T_mirror)
            #print ("B_upper: %s; max( current sum: %s, mirror_sum: %s ) = %s " %(B_upper,sum_T,sum_T_mirror, max_value))
            if B_upper > max_value: # update B only if the latest max is lower
              B_upper = max_value
              one_spanning_tree, one_mirror_tree = sG,sG_mirror
        else:
          continue
      else:
        continue
  end = timer()
  delta_time =  end-start
  return B_upper, one_spanning_tree, one_mirror_tree,delta_time

"""## PRUNING 2

1) calculate all trees and list them in order of decreasing sum of weights.
set B = min of weights of tree

2) take the smallest group of trees with the same weight, check their mirrors.

- if mirror <= smallest tree--> done

- if mirrors > smallest tree --> update B and repeat with second last etc
"""

def pruning_two(G,e_m, print_statement = False):
  """
  B_upper,one_spanning_tree, one_mirror_tree, delta_time = pruning_two(G,e_m, print_statement = True)

  """
  start = timer()


  num_v = len(G.nodes())
  must_have_edges,all_edges_list = find_musthave_edges(G) #edges that will be in tree for sure
  num_missing_edges = (n-1)-len(must_have_edges)# n is the number of nodes, n-1 is the number of edges in a spanning tree
  E_weights,E_weights_list = weights_dict_and_list(G)
  B_upper = sum(E_weights_list)

  #-----------------------------------------------------------------------------------------------------------------
  ## ALL SPANNING TREES AND THEIR WEIGHTS
  all_spanning_trees = dict()

  if print_statement == True:
    print ("found %s must-have edges out of %s of the tree" %(len(must_have_edges),n-1))
    print ("total sum of weights for G: ",B_upper)

  # if the must have edges are already all the edges that we need for the spanning tree
  if num_missing_edges == 0: # extreme case that a graph is already a spanning tree
    one_spanning_tree, one_mirror_tree = G,G

  # we need to pick the difference from the remaining unchoosen edges, "random_edges"
  else:
    random_edges = [item for item in all_edges_list if item not in must_have_edges]
    all_missing_combo = list(combinations(random_edges,num_missing_edges))
    combos = []

    if print_statement == True:
      print ("there are in total %s possible combination that could give spanning trees" %len(all_missing_combo))
      print ("calculating spanning trees of lenght %s for G with %s nodes"%(num_v-1,num_v))

    ##calculate all the spanning T and the sum of their weights
    start_combo = timer()
    l = len(all_missing_combo)
    for i in range(l):
      selected_edges = must_have_edges + list(all_missing_combo[i]) # create ONE list with all the edges
      selected_edges_noweights = [x[:2] for x in selected_edges]
      all_edges_flat = [element for tupl in selected_edges_noweights for element in tupl] #list of all nodes, with duplicates
      selected_nodes = set(all_edges_flat) #list of all nodes, without duplicates
      sG = G.edge_subgraph(selected_edges_noweights)

      #check every 10% of combination
      if (l>=100) and (i % round(l/10) == 0):
        intermediate_combo = timer()
        current_time = intermediate_combo-start_combo
        #print ("current_time: ",current_time)


      # if the combination gives a spanning tree
      if len(selected_nodes) == len(G.nodes()) and nx.is_connected(sG) :
        try: # search for cycles
          nx.find_cycle(sG) # continues after the else
        except: #if it is a proper spanning tree

          #sum its edges weights
          sG_E_weights,sG_E_weights_list = weights_dict_and_list(sG)
          sum_T = sum(sG_E_weights_list)

          #append it to the dictionary
          all_spanning_trees[sG] = sum_T
        else: continue

    #-----------------------------------------------------------------------------------------------------------------
    ## set with all the trees sum of weights
    # sorted ascending
    sorted_min = set(sorted(list(all_spanning_trees.values())))
    #-----------------------------------------------------------------------------------------------------------------

    ## find the min sum of weight over all spanning trees found
    for min_sum in sorted_min:

      # exclude from the dictionary of trees, trees with sum of values higher than B_upper
      # = take only trees whose val is less then B_upper
      # B_upper updates after every check, if solution has not been found
      selected_spanning_trees = {key:val for key, val in all_spanning_trees.items() if val <= B_upper}

      #find the batch of trees with the min sum of weight
      all_trees_min_sum = [k for k, v in selected_spanning_trees.items() if v==min_sum]

      #for each tree with minimal sum
      # check its mirror and calculate the sum
      # check if it is a solution
      # check if can update B
      #continue with next tree in the banch

      for sG in all_trees_min_sum:
        selected_edges = sG.edges.data()
        mirror_edges = []
        sum_T_mirror= 0

        for edge in selected_edges:
          if edge[0]< edge[1]:
            u,v = edge[0], edge[1]
          else:
            u,v = edge[1],edge[0],
          mirror_edge = e_m[(u,v,edge[2]['weight'])]
          mirror_edge_noweights =  mirror_edge[:2]
          sum_T_mirror += mirror_edge[2]
          mirror_edges.append(mirror_edge_noweights)

        # add the tree and his mirror to a list
        if print_statement == "mirror_details":
          print ("")
          print ("edges: ",selected_edges_noweights)
          print ("mirror_edges: ",mirror_edges)

        # create the mirror graph
        sG_mirror = G.edge_subgraph(mirror_edges)

        if sum_T_mirror <= min_sum: #solution found
          B_upper = min_sum
          one_spanning_tree, one_mirror_tree = sG,sG_mirror
          break

        else: #update B
          if B_upper > sum_T_mirror:
            B_upper = sum_T_mirror
            one_spanning_tree, one_mirror_tree = sG,sG_mirror
          continue

  end = timer()
  delta_time = end-start
  return B_upper, one_spanning_tree, one_mirror_tree, delta_time

"""## PRUNING 3 = pruning2 plus random!

1) calculate all trees and list them in order of decreasing sum of weights.
set B = min of weights of tree

2) take the smallest group of trees with the same weight, check their mirrors.

- if mirror <= smallest tree--> done

- if mirrors > smallest tree --> update B and repeat with second last etc
"""

def pruning_three(G,e_m, print_statement = False,wall_time = 600):
  """
  B_upper,one_spanning_tree, one_mirror_tree, delta_time = pruning_two(G,e_m, print_statement = True)

  """
  start = timer()


  num_v = len(G.nodes())
  must_have_edges,all_edges_list = find_musthave_edges(G) #edges that will be in tree for sure
  num_missing_edges = (n-1)-len(must_have_edges)# n is the number of nodes, n-1 is the number of edges in a spanning tree
  E_weights,E_weights_list = weights_dict_and_list(G)
  B_upper = sum(E_weights_list)
  wasted_time = 0
  #one_rand_timer = 0.00012646215000131634
  #wall_time = 600

  #-----------------------------------------------------------------------------------------------------------------
  ## ALL SPANNING TREES AND THEIR WEIGHTS
  all_spanning_trees = dict()

  if print_statement == True:
    print ("found %s must-have edges out of %s of the tree" %(len(must_have_edges),n-1))
    print ("total sum of weights for G: ",B_upper)

  # if the must have edges are already all the edges that we need for the spanning tree
  if num_missing_edges == 0: # extreme case that a graph is already a spanning tree
    one_spanning_tree, one_mirror_tree = G,G

  # we need to pick the difference from the remaining unchoosen edges, "random_edges"
  else:
    random_edges = [item for item in all_edges_list if item not in must_have_edges]
    all_missing_combo = list(combinations(random_edges,num_missing_edges))
    combos = []

    if print_statement == True:
      print ("there are in total %s possible combination that could give spanning trees" %len(all_missing_combo))
      print ("calculating spanning trees of lenght %s for G with %s nodes"%(num_v-1,num_v))

    ##calculate all the spanning T and the sum of their weights
    start_combo = timer()
    l = len(all_missing_combo)
    set_strategy = "pruning"

    for i in range(l):
      selected_edges = must_have_edges + list(all_missing_combo[i]) # create ONE list with all the edges
      selected_edges_noweights = [x[:2] for x in selected_edges]
      all_edges_flat = [element for tupl in selected_edges_noweights for element in tupl] #list of all nodes, with duplicates
      selected_nodes = set(all_edges_flat) #list of all nodes, without duplicates
      sG = G.edge_subgraph(selected_edges_noweights)

      #check every 10% of combination
      if (l>=100) and (i>0) and (i % round(l/10) == 0):
        print (set_strategy)
        intermediate_combo = timer()
        current_time = intermediate_combo-start_combo
        estimated_tot_time = (l/i)*current_time
        print ("current_time: ",current_time)
        print ("estimated_tot_time: ",estimated_tot_time)

        if estimated_tot_time > wall_time:
          set_strategy = "random"
          print ("changed strategy")
          wasted_time = current_time
          break
        else:
          set_strategy = "pruning"


      # if the combination gives a spanning tree
      if len(selected_nodes) == len(G.nodes()) and nx.is_connected(sG) :
        try: # search for cycles
          nx.find_cycle(sG) # continues after the else
        except: #if it is a proper spanning tree

          #sum its edges weights
          sG_E_weights,sG_E_weights_list = weights_dict_and_list(sG)
          sum_T = sum(sG_E_weights_list)

          #append it to the dictionary
          all_spanning_trees[sG] = sum_T
        else: continue

    print ("current strategy :",set_strategy)
    if set_strategy == "pruning":
      #-----------------------------------------------------------------------------------------------------------------
      ## set with all the trees sum of weights
      # sorted ascending
      sorted_min = set(sorted(list(all_spanning_trees.values())))
      #-----------------------------------------------------------------------------------------------------------------

      ## find the min sum of weight over all spanning trees found
      for min_sum in sorted_min:

        # exclude from the dictionary of trees, trees with sum of values higher than B_upper
        # = take only trees whose val is less then B_upper
        # B_upper updates after every check, if solution has not been found
        selected_spanning_trees = {key:val for key, val in all_spanning_trees.items() if val <= B_upper}

        #find the batch of trees with the min sum of weight
        all_trees_min_sum = [k for k, v in selected_spanning_trees.items() if v==min_sum]

        #for each tree with minimal sum
        # check its mirror and calculate the sum
        # check if it is a solution
        # check if can update B
        #continue with next tree in the banch

        for sG in all_trees_min_sum:
          selected_edges = sG.edges.data()
          mirror_edges = []
          sum_T_mirror= 0

          for edge in selected_edges:
            if edge[0]< edge[1]:
              u,v = edge[0], edge[1]
            else:
              u,v = edge[1],edge[0],
            mirror_edge = e_m[(u,v,edge[2]['weight'])]
            mirror_edge_noweights =  mirror_edge[:2]
            sum_T_mirror += mirror_edge[2]
            mirror_edges.append(mirror_edge_noweights)

          # add the tree and his mirror to a list
          if print_statement == "mirror_details":
            print ("")
            print ("edges: ",selected_edges_noweights)
            print ("mirror_edges: ",mirror_edges)

          # create the mirror graph
          sG_mirror = G.edge_subgraph(mirror_edges)

          if sum_T_mirror <= min_sum: #solution found
            B_upper = min_sum
            one_spanning_tree, one_mirror_tree = sG,sG_mirror
            break

          else: #update B
            if B_upper > sum_T_mirror:
              B_upper = sum_T_mirror
              one_spanning_tree, one_mirror_tree = sG,sG_mirror
            continue
    else:
      one_rand_timer = exploratory_random (B_upper, G,R,e_m,mapping_edges_indexes, list_edges,num_trials = 10)
      print ("one rand takes: ",one_rand_timer)
      #try with loop over many random strings
      tot_time_required = l*2*one_rand_timer
      print ("tot_time_required: ",tot_time_required)
      if tot_time_required< wall_time-wasted_time:
        num_trials = l*2
      else:
        num_trials =int((.9*(wall_time-wasted_time))/one_rand_timer)

      if num_trials > 0:
        print ("will try %s rand over %s necessary"%(num_trials,l))
        B_upper, Best_couple = max_trials_random (B_upper,G,R,e_m,mapping_edges_indexes, list_edges,num_trials)
      one_spanning_tree, one_mirror_tree = Best_couple

  end = timer()
  delta_time = end-start
  return B_upper, one_spanning_tree, one_mirror_tree, delta_time


#---------------------------------------------
"""MAIN execution"""

myarr = []
for line in fileinput.input():
    line = line.rstrip()
    myarr.append(line)

#BUILD THE GRAPH
n = int(myarr[0]) # number of vertices
m = int(myarr[1]) # number of edges
E = [] # empty list of edges
mapping_edges_indexes = dict() # empty dictionary to keep the edges ordering i--> u,v,w
mapping_output = dict() #reverse dictionary
edge_idx = 1
for row in myarr[2:]: # only the edges here
  string2int_list = list(map(int ,row.split(' ')))
  u,v,w = (string2int_list[0],string2int_list[1],string2int_list[2])
  mapping_edges_indexes[edge_idx] = (u,v,w) # eg e_1 = (1,2)
  mapping_output[(u,v,w)] = edge_idx
  E.append((u,v,w))
  edge_idx+=1

G = nx.Graph()
G.add_weighted_edges_from(E)

## INITIALIZATION
k = G.number_of_nodes()-1 # number of edges in the tree
list_edges = list(G.edges(data=True)) # all the edges, without any particular sorting
e_m = dict_edges_mirror(mapping_edges_indexes)# create mirror dictionary following the order with which the edges are given
E_weights,E_weights_list = weights_dict_and_list(G)
B_upper = sum(E_weights_list)
Best_couple = (G,G)

## A5: PRUNING 2 - with preselection of edges
B_upper,subgraph,subgraph_mirror, delta_time = pruning_two(G,e_m, print_statement = False)
#or
#B_upper,subgraph,subgraph_mirror, delta_time = pruning_three(G,e_m, print_statement = False)

## results
solution_edges = flatten_edges_with_weights(subgraph.edges.data())

if len(solution_edges) != k:
    sys.stdout.write("NO")
else:
    sorted_indexes = []
    for edge in solution_edges:
        solution_index = mapping_output[edge]
        sorted_indexes.append(solution_index)
    sorted_indexes = sorted(sorted_indexes) # do we need this in order?
    for solution_index in sorted_indexes:
        sys.stdout.write("%i\n"%solution_index) #\n = new line or \r = overwrite
      #sys.stdout.write()
    sys.stdout.write(str(B_upper)+"\n")
