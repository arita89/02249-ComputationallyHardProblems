# -*- coding: utf-8 -*-
"""Assignment_basic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ki6on3yicNlYddffIWRhY_CoR8NULXXg

## Assignment 1
# 02239- Computational Hard Problems
due 02-11-2020
"""
#!/usr/bin/env python3
#-------------------------------
# import statements

#import numpy as np
#import statistics
#from statistics import mean
from itertools import combinations
#import copy
import math
import os
import sys

import timeit
from timeit import default_timer as timer
import fileinput
from collections import defaultdict

# function to build a graph
# function to check is graph is connected = BFS
# function to check for cycles = DFS
# function to check for bridges

"""## Fuctions

### MST
"""

## Find Minimum Spanning Tree Kruskal
# my  own implementation of Kruskal's algorithm.
def find_MST(new_edges,print_stat = False):
  """
  give edges of the graph (flat!) or graph
  """
  #sort edges by weight
  new_edges.sort(key = lambda x: x[2])
  if len(new_edges) >0:

    # take the smallest edge, add to the edges of the Tree
    start = tuple(new_edges[0])
    all_mst_edges = []
    all_mst_edges.append(start)

    if print_stat == True:
      print ("start: %s" %(new_edges[:1]))

    # for each edge in the graph after the first
    for i in range(1,len(new_edges)): # O(n-1)
      #print ("")
      proposed_edge = new_edges[i]
      proposed_edge = tuple(proposed_edge)
      all_mst_edges.append(proposed_edge)
      #print ("proposed_edge: (%s,%s,%s)" %(proposed_edge))
      # take nodes 0f the next smallest edge
      #print ("MST edges: ",all_mst_edges)

      neightbours = find_all_neightbours(all_mst_edges, False, False)
      if (cycle_exists(neightbours) == False):
        if print_stat == True:
          print ("proposed_edge: (%s,%s,%s) - added" %(proposed_edge))
        else:
          continue
      else:
        if print_stat == True:
          print ("proposed_edge :(%s,%s,%s)- cycle created, discarded" %proposed_edge)
        #u,v,w = proposed_edge[0][0],proposed_edge[0][1],proposed_edge[0][2]
        all_mst_edges.remove(proposed_edge)

    if print_stat == True:
      print ("end, minimum spanning tree found over edges :")
      #print (all_mst_edges)

    return all_mst_edges
  else:
    if print_stat == True:
      print ("give  edges to calculate MST")
      print ("")

"""### find B_upper"""

def find_B_upper(selected_edges,mirror_edges):
  """
  B_upper,sum_T,sum_mirror =  max_and_plot_sG_sGmirror(subgraph,subgraph_mirror,plot_statement = True)
  """
  sum_T = sum(w for _,_,w in selected_edges)
  sum_mirror = sum(w for _,_,w in mirror_edges)
  B_upper = max (sum_T,sum_mirror)

  return B_upper,sum_T,sum_mirror

"""## flatten edges"""

def flatten_edges_with_weights(edges):
  """
  edges = G.edges.data()
  input is a G.edge = u,v,w['weight']
  output is a Tuple = (u,v,w)
  """
  #return [(x[0],x[1],x[2]['weight'] )for x in list(edges)]
  flat_edges = []
  for x in list(edges):
      if x[0] < x[1]:
          u,v = x[0],x[1]
      else:
          u,v = x[1],x[0]
      flat_edges.append((u,v,x[2]['weight'] ))
  return flat_edges


"""## Exploratory random"""

def exploratory_random (B,e_m,mapping_edges_indexes, list_edges,num_trials = 10,cover_factor =1, print_statement = False):
  """
  one_rand_timer = exploratory_random (B,e_m,mapping_edges_indexes, list_edges,num_trials = 10,cover_factor =1, print_statement = False)
  """
  start = timer()
  for i in range(num_trials):
    R = rand_bin_array(k, m) #R0
    selected_edges,mirror_edges = build_T_Tmirror(R,e_m, mapping_edges_indexes,list_edges,list_nodes, print_statement)
    if len(selected_edges) > 0:
      max_value,sum_T,sum_mirror =  find_B_upper(selected_edges,mirror_edges)
      if max_value <= B:
        B = max_value
        Best_couple = (selected_edges,mirror_edges)
        #print ("found a smaller B: ",B)
  end = timer()
  one_rand_timer = (end - start)/num_trials
  return one_rand_timer

"""## max trials random"""

def max_trials_random (e_m, mapping_edges_indexes,list_edges,list_nodes, num_trials,print_statement = False):
  """
  B, Best_couple = max_trials_random (e_m, mapping_edges_indexes,list_edges,list_nodes, num_trials)
  """
  Best_couple = G,G
  for i in range(num_trials):
    R = rand_bin_array(k, m) #R0
    #subgraph,subgraph_mirror= check_ST(G,R,e_m, list_edges,print_statement = False)
    selected_edges,mirror_edges = build_T_Tmirror(R,e_m, mapping_edges_indexes,list_edges,list_nodes, print_statement)
    if len(selected_edges) > 0:
      max_value,sum_T,sum_mirror =  find_B_upper(selected_edges,mirror_edges)
      if max_value <= B:
        B = max_value
        Best_couple = (selected_edges,mirror_edges)

  return B, Best_couple

"""
## Build spanning Tree from Random String R0
- read random input
- select edges
- if tree find mirror
- returns tree and its mirror as Graphs
"""

def build_T_Tmirror(R,e_m, mapping_edges_indexes,list_edges,list_nodes, print_statement = False):
  """
  sG,sG_mirror= build_T_Tmirror(R,e_m, mapping_edges_indexes, list_edges,print_statement = True)

  key: value
  index: (u,v,w)
  keys go from 1 to k

  """
  n = len (list_nodes)

  # create selected_edges from R0
  selected_edges = []
  for i in range(len(R)): # k = n-1 number of edges in a spaning tree, i = 0...k-1 edges (they are k)
    if R[i] == 0:
      continue
    else:
      selected_edges.append(mapping_edges_indexes[i+1])

  #create a set of vertices from the selected edges
  selected_edges_noweights = [x[:2] for x in selected_edges]
  all_edges_flat = [element for tupl in selected_edges_noweights for element in tupl]
  selected_nodes = set(all_edges_flat)
  #print (selected_nodes)

  # to check that the combination gives a spanning tree:
  # all nodes are covered
  # the edges create a connected graph
  # there is no cycle
  neightbours = find_all_neightbours(selected_edges, False)

  if (len(selected_nodes) == n) and is_connected(neightbours, n) and (cycle_exists(neightbours) == False):
    mirror_edges = []
    for edge in selected_edges:
      mirror_edge = e_m[(edge[0],edge[1],edge[2])]
      #mirror_edge_noweights =  mirror_edge[:2]
      mirror_edges.append(mirror_edge)

    # add the tree and his mirror to a list
    if print_statement == True:
      print ("")
      print ("graph edges: ",[(u,v) for (u,v,w) in list_edges])
      print ("random bin sequence",R)
      print ("selected_edges: ",selected_edges)
      print ("mirror_edges: ",mirror_edges)

    #sG = G.edge_subgraph(selected_edges_noweights)
    #sG_mirror = G.edge_subgraph(mirror_edges)
    return selected_edges,mirror_edges
  else:
    if print_statement == True:
      print ("the edges selected with R0 are not a spanning tree")
    return list_edges,list_edges

"""### dict_edges_mirror(mapping_edges_indexes)"""

"""##dictionaries of edges and their mirror - keeping the order given by the input
"""
def dict_edges_mirror(mapping_edges_indexes):
  """
  e_m = dict_edges_mirror(mapping_edges_indexes)

  e_m eg
  (1, 2, 1): (1, 3, 3)

  """
  start = timer()
  e_m = dict()
  m = len(mapping_edges_indexes.keys())
  for i in range(1,m+1):
    this_e = mapping_edges_indexes[i]
    mirror_e = mapping_edges_indexes[m+1-i]
    if not (this_e) in e_m.keys():
        e_m[this_e] = mirror_e
  end = timer()
  #print("computational time: ",end-start)
  return e_m

"""### random"""

"""##n choose k"""
def n_choose_k(n, k):
    return math.factorial(n) // math.factorial(k) // math.factorial(n - k)

"""## create a random string of bits"""
def rand_bin_array(K, N):
  """
  arr = rand_bin_array(K, N)
  """
  arr = np.zeros(N)
  arr[:K]  = 1
  np.random.shuffle(arr)
  return arr

"""### sum_with_mirror_edges(e_m)"""

"""## create new edges which are sum edges with their mirror
new_edge_i = e_i + e_m+1-i
"""
def sum_with_mirror_edges(e_m):
  """
  new_edges,new_edges_dict = sum_with_mirror_edges(edges)
  """
  #new_edges_dict= copy.deepcopy(edges)
  new_edges = []
  for edge in list(e_m.keys()):
    u,v,w = edge
    u_m,v_m,w_m = e_m[edge]
    new_weight = w + w_m
    difference_weight = (w-w_m)
    new_edges.append((u,v,new_weight))
  return new_edges#,new_edges_dict

"""### find neightbours"""

# find all nodes reachable from one node
def find_all_neightbours(list_edges,start_from_zero = False, print_statement = False):
  neightbours = dict()
  for edge in list_edges:
    if print_statement == True:
      print (edge)
    (u,v,w) = edge

    # this is due to the fact that our nodes start from 1 and not from zero,
    # in the bridge fuction its a mess with dimensionalities if the zero is skipped
    # so just moved the input backwards of one and then the output will be output+1
    if start_from_zero == True:
      u = u-1
      v = v-1

    #append neighbours of each node
    if not u in neightbours.keys():
      this_node_neighbours_list = [v]
      neightbours[u] = this_node_neighbours_list
    else:
      this_node_neighbours_list = neightbours[u]
      this_node_neighbours_list.append(v)
      neightbours[u] = this_node_neighbours_list
    if not v in neightbours.keys():
      this_node_neighbours_list = [u]
      neightbours[v] = this_node_neighbours_list
    else:
      this_node_neighbours_list = neightbours[v]
      this_node_neighbours_list.append(u)
      neightbours[v] = this_node_neighbours_list
  return neightbours

"""### check if is connected"""

# simple BFS
def bfs(neightbours,node):
  visited = [] # List to keep track of visited nodes.
  queue = []     #Initialize a queue
  visited.append(node)
  queue.append(node)

  while queue:
    s = queue.pop(0)
    #print (s, end = " ")

    for neighbour in (neightbours[s]):
      if neighbour not in visited:
        visited.append(neighbour)
        queue.append(neighbour)
  return visited

# BFS for checking that a graph  is connected
# starting from one arbitrary node
# i can reach all the others
def is_connected(neightbours, n):
  node = 1 #arbitrary choice of starting node
  visited = bfs(neightbours, node)
  return (len(visited)==n)

"""### find cycles"""

##
# input G = neightbours
# simple DFS
def dfs_visit(G, u, found_cycle, pred_node, marked):
    if found_cycle[0]:
        return
    marked[u] = True
    # Check neighbors of [u]
    for v in G[u]:
        # If neighbor is marked and not predecessor
        if marked[v] and v != pred_node:
             # then a cycle exists.
            found_cycle[0] = True
            return
        if not marked[v]:
            # recurse!
            dfs_visit(G, v, found_cycle, u, marked)

# check that there is no cycle in the list of neightbour that you push in
def cycle_exists(G):
    # All nodes are initially unmarked.
    marked = { u : False for u in G }
    # Define found_cycle as a list so we can change
    found_cycle = [False]
    for u in G:
        if not marked[u]:
            dfs_visit(G, u, found_cycle, u, marked)     # - u is its own predecessor initially
        if found_cycle[0]:
            break
    return found_cycle[0]

"""### Find bridges"""

# find bridges
"""
https://leetcode.com/problems/critical-connections-in-a-network/discuss/504797/Python-Find-bridgesarticulation-points-with-detailed-explanation
https://stackoverflow.com/questions/15939558/bridge-determination-in-undirected-graphs
https://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/

How to find all bridges in a given graph?
A simple approach is to one by one remove all edges and see if removal of an edge causes disconnected graph. Following are steps of simple approach for connected graph.
For every edge (u, v), do following
a) Remove (u, v) from graph
b) See if the graph remains connected (We can either use BFS or DFS)
c) Add (u, v) back to the graph.

There is the brute force shite that takes O(E*(E+V)) ... nope.
This is a known O(V+E) algorithm to find all Bridges.
TARJAN alg.
We do DFS traversal of the given graph.
In DFS tree an edge (u, v) (u is parent of v in DFS tree)
is bridge if there does not exit any other alternative to reach u or an ancestor of u from subtree rooted with v.
the value low[v] indicates earliest visited vertex reachable from subtree rooted with v.
The condition for an edge (u, v) to be a bridge is, “low[v] > disc[u]”.

"""
def bridgeUtil(u, visited, parent, low, disc, Time,bridges_list):
    #bridges_list = []
    # Mark the current node as visited and print it
    visited[u]= True

    # Initialize discovery time and low value
    #print ("analyzing node :" ,u)
    disc[u] = Time
    low[u] = Time
    Time += 1

    #Recur for all the vertices adjacent to this vertex
    for v in neightbours_formatted[u]:
        # If v is not visited yet, then make it a child of u
        # in DFS tree and recur for it
        #print ("%s neightbour of %s " %(v,u))
        if visited[v] == False :
            parent[v] = u
            bridgeUtil(v, visited, parent, low, disc, Time,bridges_list)

            # Check if the subtree rooted with v has a connection to
            # one of the ancestors of u
            low[u] = min(low[u], low[v])


            ''' If the lowest vertex reachable from subtree
            under v is below u in DFS tree, then u-v is
            a bridge'''
            if low[v] > disc[u]:
                #print ("bridge found : %d %d" %(u+1,v+1))
                if u <v:
                  bridges_list.append((u+1,v+1))
                else:
                  bridges_list.append((v+1,u+1))

                return bridges_list
                #yield ("%d %d" %(u,v))
                #bridges_list.append((u,v))


        elif v != parent[u]: # Update low value of u for parent function calls.
            low[u] = min(low[u], disc[v])

   #return bridges_list


# DFS based function to find all bridges. It uses recursive
# function bridgeUtil()
def bridge(neightbours_formatted, list_nodes,Time):
    v = len(list_nodes)
    bridges_list = []
    # Mark all the vertices as not visited and Initialize parent and visited,
    # and ap(articulation point) arrays
    visited = [False] * (v)
    disc = [float("Inf")] * (v)
    low = [float("Inf")] * (v)
    parent = [-1] * (v)

    #print (visited)
    #print (disc)
    #print (low)
    #print (parent)

    # Call the recursive helper function to find bridges
    # in DFS tree rooted with vertex 'i'
    for i in range(v):
        if visited[i] == False:
          bridges_list = bridgeUtil(i, visited, parent, low, disc,Time,bridges_list)

    return bridges_list

"""### Algorithm -pruning"""

## TEST code
#B_upper,one_spanning_tree, one_mirror_tree, delta_time = pruning(list_edges,list_nodes, e_m, E_weights_list, print_statement = True,wall_time = 600)

"""## PRUNING 3 = pruning2 plus random!
1) calculate all trees and list them in order of decreasing sum of weights.
set B = min of weights of tree
2) take the smallest group of trees with the same weight, check their mirrors.
- if mirror <= smallest tree--> done
- if mirrors > smallest tree --> update B and repeat with second last etc
"""

def pruning(list_edges,list_nodes, e_m, E_weights_list, print_statement = False,wall_time = 600):
  """
  B_upper,one_spanning_tree, one_mirror_tree, delta_time = pruning_three(G,e_m, print_statement = True)

  """
  start = timer()

  #initialize
  n = len(list_nodes)
  B_upper = sum(E_weights_list)
  wasted_time = 0

  #edges that will be in tree for sure
  must_have_edges,all_edges = find_musthave_edges(list_edges,list_nodes,edges_dict) #output (u,v,w)
  num_missing_edges = (n-1)-len(must_have_edges)# n is the number of nodes, n-1 is the number of edges in a spanning tree
  if print_statement == True:
      print("")
      print ("all edges: ", len(all_edges))
      print ("must_have_edges: ", len(must_have_edges))

  l = n_choose_k(len(all_edges)-len(must_have_edges), num_missing_edges) #number of combinations
  set_limit = 5*(10**5)

  #-----------------------------------------------------------------------------------------------------------------
  ## ALL SPANNING TREES AND THEIR WEIGHTS
  all_spanning_trees = dict() # index: list of edges
  all_sums =  dict()# same index: sum of the weights of the edges of the correspondent tree
  index_counter = 0

  if print_statement == True:
    print("")
    print ("number of edges: %s" %n)
    print ("found %s must-have edges out of %s of the tree" %(len(must_have_edges),n-1))
    print ("total sum of weights for G: ",B_upper)
    print ("total number of combinations: ",l)

  # if the must have edges are already all the edges that we need for the spanning tree
  if num_missing_edges == 0: # extreme case that a graph is already a spanning tree
    one_spanning_tree, one_mirror_tree = all_edges,all_edges

  elif l > set_limit:
        set_strategy = "random"   #if the number of combinations is higher than 500.000
  else:
        set_strategy = "exact_result"
        random_edges = [item for item in all_edges if item not in must_have_edges]
        all_missing_combo = list(combinations(random_edges,num_missing_edges))
        combos = []

        if print_statement == True:
          print ("there are in total %s possible combination that could give spanning trees" %len(all_missing_combo))
          print ("calculating spanning trees of lenght %s for G with %s nodes"%(n-1,n))
          print ("")

        ##calculate all the spanning T and the sum of their weights
        start_combo = timer()
        l = len(all_missing_combo)
        #l = 30                                                               #<----------------------------------------------------------------------------- TESTING, delete afterwards (in 30 only 4 trees!)

        # iterate through the combinations
        for i in range(l):
          selected_edges = must_have_edges + list(all_missing_combo[i]) # create ONE list with all the edges
          sum_T = 0
          selected_edges_noweights = [x[:2] for x in selected_edges]
          #sum_T = [sum_T += x[2] for x in selected_edges]
          #if sum_T > B_upper:
            #break


          all_edges_flat = [element for tupl in selected_edges_noweights for element in tupl] #list of all nodes, with duplicates
          selected_nodes = set(all_edges_flat) #list of all nodes, without duplicates
          #sG = G.edge_subgraph(selected_edges_noweights)

          #check every 10% of combination
          if (l>=10) and (i>0) and (i % round(l/10) == 0):
            intermediate_combo = timer()
            current_time = intermediate_combo-start_combo
            estimated_tot_time = (l/i)*current_time
            if print_statement == True:
                print ("%s/%s) current_time: %.7f, estimated_tot_time: %.7f"%(i,l,current_time,estimated_tot_time))
            if estimated_tot_time > wall_time:
              set_strategy = "random"
              if print_statement == True:
                print ("changed strategy")
              wasted_time = current_time
              break
            else:
              set_strategy = "exact_result"


          # to check that the combination gives a spanning tree:
          # all nodes are covered
          # the edges create a connected graph
          # there is no cycle
          neightbours = find_all_neightbours(selected_edges, False)

          if (len(selected_nodes) == n) and is_connected(neightbours, n) and (cycle_exists(neightbours) == False):
            #sum its edges weights
            sum_T = sum(w for _,_,w in selected_edges)

            #append it to the dictionaries
            ## cant use list of edges as a key, its unhashable!
            all_spanning_trees[index_counter] = selected_edges
            all_sums[index_counter] =sum_T
            index_counter +=1

          else: continue

  ## control block to be deleted
  #for i in range(index_counter+1):
    #print ("")
    #print (i, all_sums[i] )
    #print (all_spanning_trees[i])

  if print_statement == True:
    print ("current strategy :",set_strategy)

  if set_strategy == "exact_result":
      #-----------------------------------------------------------------------------------------------------------------
      ## set with all the trees sum of weights
      # sort the dictionary of values
      # take the list of keys of the sorted dictionary of values
      # with each index take the list of edges (tree) from all_spanning_trees
      # now you have all the spanning trees sorted per ascending total sum of weights
      # sorted ascending
      sorted_indexes = list (k for k, v in sorted(all_sums.items(), key=lambda item: item[1]))
      sorted_min = list (v for k, v in sorted(all_sums.items(), key=lambda item: item[1]))


      #print ({k: v for k, v in sorted(all_sums.items(), key=lambda item: item[1])})
      #print (sorted_indexes)
      #print (sorted_min)

      #sorted_min = set(sorted(list(all_sums.values())))
      #-----------------------------------------------------------------------------------------------------------------
      if print_statement == True:
        print ("---------------------------------")
        print (sorted(all_sums.items()))
        print ("---------------------------------")

      ##
      ## find the min sum of weight over all spanning trees found
      for min_sum in sorted_min:
        #print ("---------------------------------")
        #print ("block of trees: ")
        #print ("min_sum: ",min_sum)

        # exclude from the dictionary of trees, trees with sum of values higher than B_upper
        # = take only trees whose val is less then B_upper
        # B_upper updates after every check, if solution has not been found

        selected_indexes_of_spanning_trees = list(key for key, val in sorted(all_sums.items()) if val <= B_upper)
        #for key, val in sorted(all_sums.items()):
           #if val <= B_upper:
             #print (key,val)
        #print (selected_indexes_of_spanning_trees)

        #try_s = timer()
        selected_spanning_trees = dict()
        for index in selected_indexes_of_spanning_trees:
          selected_spanning_trees[index]= all_spanning_trees[index] #spanning trees with correspondent value sum_t less than B

        #print ("found %s spanning trees  "%len(selected_spanning_trees))
        #print ((selected_spanning_trees))
        if min_sum >= B_upper: #there arent any more spanning trees with B less than B_upper
          one_spanning_tree, one_mirror_tree = selected_edges,mirror_edges#solution found#
          #print (B_upper,one_spanning_tree)
          break

        else:
          #find the batch of trees with the min sum of weight
          #for index,val in sorted(all_sums.items()):
             #if val ==min_sum:
              #print (index,val)

          all_trees_min_sum = [selected_spanning_trees[index] for index,val in sorted(all_sums.items()) if val == min_sum]
          #try_end = timer()
          #print ("1:",try_end-try_s) # this is more efficient!
          #print ("1:",all_trees_min_sum)

          # find the batch of trees with the min sum of weight
          #all_trees_min_sum = [all_spanning_trees[index] for index,val in all_sums.items() if val ==min_sum]
          #try_end = timer()
          #print ("2:",try_end-try_s)
          #print ("1:",all_trees_min_sum)

          # this is a list of lists [[list of edges of one tree with min sum], [list of edges of another tree with min sum ]]
          all_trees_min_sum = [selected_spanning_trees[index] for index,val in all_sums.items() if val ==min_sum]

          #for each tree with minimal sum
          # check its mirror and calculate the sum
          # check if it is a solution
          # check if can update B
          #continue with next tree in the banch

          for selected_edges in all_trees_min_sum:
            mirror_edges = []
            sum_T_mirror= 0

            for edge in selected_edges:

              if edge[0]< edge[1]:
                u,v,w = edge[0], edge[1],edge[2]
              else:
                u,v,w = edge[1],edge[0],edge[2]
              mirror_edge = e_m[(u,v,w)]
              #mirror_edge_noweights =  mirror_edge[:2]
              sum_T_mirror += mirror_edge[2]
              mirror_edges.append(mirror_edge)

            # create the mirror graph
            #sG_mirror = G.edge_subgraph(mirror_edges)
            #print (sum_T_mirror,min_sum)
            #print ("B_upper:", max(sum_T_mirror,min_sum))

            if sum_T_mirror <= min_sum: #solution found
              B_upper = min_sum
              one_spanning_tree, one_mirror_tree = selected_edges,mirror_edges
              break

            else: #update B
              if B_upper > sum_T_mirror:
                B_upper = sum_T_mirror
                one_spanning_tree, one_mirror_tree = selected_edges,mirror_edges
              continue

  else: # we dont ensure exact solution, but we try to get to something
      #maybe random can cover most cases?
      # random
      one_rand_timer = exploratory_random (B_upper,e_m,mapping_edges_indexes, list_edges,num_trials = 10,cover_factor =1, print_statement = False)
      cover_factor = 1
      tot_time_required = l*cover_factor*one_rand_timer
      if print_statement == True:
        print ("tot time needed:",tot_time_required)
      remaining_time = (wall_time-wasted_time)*0.9
      if tot_time_required< remaining_time: # we have enough time to cover almost/all cases with random (if we are lucky)
        num_trials = l*cover_factor
      else:# we dont have enough time
        if remaining_time > tot_time_required/3:
            num_trials =int((.9*(wall_time-wasted_time))/one_rand_timer)
        else:
            num_trials =0
      if print_statement == True:
        print ("will try %s rand over %s necessary"%(num_trials,l))

      if num_trials > 0:#<----------------------------------------------------------------------------- TESTING still neeeded try with input03
          set_strategy = "random "
          if print_statement == True:
              print ("current strategy :",set_strategy)
              print ("one rand takes: ",one_rand_timer)
              print ("tot_time_required: ",tot_time_required)
              print ("will try %s rand over %s necessary"%(num_trials,l))
          #B_upper, Best_couple = max_trials_random (B_upper,e_m,mapping_edges_indexes, list_edges,num_trials)
          B, Best_couple = max_trials_random (e_m, mapping_edges_indexes,list_edges,list_nodes, num_trials)
          one_spanning_tree, one_mirror_tree = Best_couple

      else:
          set_strategy = "MST of sum of edges"
          if print_statement == True:
              print ("current strategy :",set_strategy)

          new_edges  = sum_with_mirror_edges(e_m) # sum of each edge and its mirror
          #bigG= nx.Graph()
          #bigG.add_weighted_edges_from(new_edges)
          one_spanning_tree= find_MST(new_edges, print_stat = False)#<----------------------------------------------------------------------------- TESTING
          B_T = 0
          B_mT = 0
          one_mirror_tree = []
          for edge in (one_spanning_tree):
              if edge[0]< edge[1]:
                  u,v= edge[0], edge[1]
              else:
                  u,v= edge[1],edge[0]
              w = (edges_dict[(u,v)]) # take original weight
              u_m,v_m,w_m = e_m[(u,v,w)]
              one_mirror_tree.append((u_m,v_m,w_m))
              B_T +=w
              B_mT +=w_m
          B_upper = max(B_T,B_mT)

  end = timer()
  delta_time = end-start
  if print_statement == True:
      print ("time needed: " ,delta_time)
  return B_upper, one_spanning_tree, one_mirror_tree, delta_time

"""
## EDGES SELECTION
### find Must-have edges
function that given a graph, finds which edges MUST be in the spanning tree.
how?
linear search: take one edge out at the time, is the graph still connected?
if YES --> continue
if NO --> add to the pool of mandatory edges,
once the list of mandatory edges is created, pick the possible combinations of trees by choosing rondomly the remaining edges.
time complexity: O(m)+time to create the graph with reduced edges + time to check that the graph is not connected = O(m+n)
"""

def find_musthave_edges(list_edges,list_nodes,edges_dict):
    """
    must_have_edges,all_edges = find_musthave_edges(list_edges,list_nodes,edges_dict)
    both lists in form: [(u1,v1,w1)...(uj,vj,wj)]
    """
    neightbours_formatted = find_all_neightbours(list_edges, True)
    must_have_list  = bridge(neightbours_formatted, list_nodes, Time = 0)


    # check if must_have_list is empty
    #print (type(must_have_list))
    #NoneType = type(None)
    #print (isinstance(must_have_list, NoneType))

    # bridges returns only the nodes (u,v) $O(m + n)$,
    # where $n$ is the number of nodes in the graph
    # and $m$ is
    # the number of edges.
    must_have_edges = []
    if (type(must_have_list) is list): # if there are bridges
    #if not(isinstance(must_have_list, NoneType):
      for edge in must_have_list:
        u,v = edge[0],edge[1]
        if edge[0]< edge[1]:
          u,v = edge[0],edge[1]
          edge = (u,v,edges_dict[(u,v)])
        else:
          u,v = edge[1],edge[0]
          edge = (u,v,edges_dict[(u,v)])
        must_have_edges.append(edge)

    all_edges= []
    for (u,v,w) in list_edges: # each edge is (u,v,w)
      if u <v:
        edge = (u,v,w)
      else:
        edge = (v,u,w)
      all_edges.append(edge)
    return must_have_edges,all_edges

"""
## Input

from google.colab import files

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))
"""
#--------------------------------------------
"""IMPORT """
#local
#test = "/content/test03.uwg"
#test = open(test, "r")

#myarr = []
#for line in test: # this is a flow and goes through ONCE
  #line = line.rstrip()
  #myarr.append((line))

# uncomment to read stdin
myarr = []
for line in fileinput.input():
    line = line.rstrip()
    myarr.append(line)

"""## MAIN"""

#---------------------------------------------
"""MAIN execution"""

#INITIALIZATION
n = int(myarr[0]) # number of nodes
m = int(myarr[1]) # number of edges
k = n-1 # number of edges in the tree

list_edges  = [] # empty list of edges
list_nodes = [] # empty list of nodes
E_weights_list = [] # empty list of edges weights

edges_dict = dict()
mapping_edges_indexes = dict() # empty dictionary to keep the edges ordering i--> u,v,w
mapping_output = dict() #reverse dictionary
neightbours = dict()

edge_idx = 1
for row in myarr[2:]: # only the edges here
  string2int_list = list(map(int ,row.split(' ')))
  u,v,w = (string2int_list[0],string2int_list[1],string2int_list[2])
  mapping_edges_indexes[edge_idx] = (u,v,w) # eg e_1 = (1,2)
  mapping_output[(u,v,w)] = edge_idx
  list_edges.append((u,v,w))
  if u< v:
      edges_dict[(u,v)] = w
  else:
      edges_dict[(v,u)] = w
  E_weights_list.append(w)

  #append nodes
  if not u in list_nodes:
	  list_nodes.append(u)
  if not v in list_nodes:
	  list_nodes.append(v)
  edge_idx+=1

B_upper = sum(E_weights_list) #initial B
Best_couple = (list_edges,list_edges)

#
e_m = dict_edges_mirror(mapping_edges_indexes)# create mirror dictionary following the order with which the edges are given
neightbours= find_all_neightbours(list_edges)

#B_upper,subgraph,subgraph_mirror = pruning_three(G,e_m, print_statement = False)
B_upper,one_spanning_tree, one_mirror_tree, delta_time = pruning(list_edges,list_nodes, e_m, E_weights_list, print_statement = False,wall_time = 600)

## results
#solution_edges = sorted(one_spanning_tree, key=lambda x: mapping_output[x])
#for edge in solution_edges:
  #solution_index = mapping_output[edge]
  #print ("%i\r"%solution_index) #\n or \r?
  #sys.stdout.write()

if len(solution_edges) != k:
    sys.stdout.write("NO")
else:
    solution_edges = sorted(one_spanning_tree, key=lambda x: mapping_output[x])
    for solution_index in sorted_indexes:
        sys.stdout.write("%i\n"%solution_index) #\n = new line or \r = overwrite
      #sys.stdout.write()
    sys.stdout.write(str(B_upper)+"\n")
#print (B_upper)
