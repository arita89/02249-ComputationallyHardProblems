# -*- coding: utf-8 -*-
"""Exercises_7_OPT2_works.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pcu4i8yHkW5SK3tDXm1H6CKmHuAEeWjg

# install
"""

!pip install colorama

"""# import"""

import re
import random
import numpy as np
import pandas as pd
from colorama import Fore, Back, Style
from itertools import cycle, islice, dropwhile
import collections

"""# Definitions Theory

* **Search space $S .$**

 A typically finite set, in which certain solution (e. g., of optimal quality) are sought. Examples:
  - $\{0,1\}^{n}$, all bit strings of length $n$. In this way, an assignment of truth values to $n$ boolean variables can be coded.
  - $\Pi_{n}:=$ set of all permutations on $\{1, \ldots, n\} .$ In this way, a solution to the TSP can be coded.

* **Fitness function $f$.**

 Maps $x \in S \mapsto f(x) \in \mathbb{R},$ i. e., returns a value for every search point. Examples:
  - $f:\{0,1\}^{n} \rightarrow \mathbb{R}$ returns the number of satisfied clauses w. r. t. the MAX-3-SAT problem, using the search space $\{0,1\}^{n}$ as described above.
  - $f: \Pi_{n} \rightarrow \mathbb{R}$ returns the length of a TSP-tour.

# Mutations Theory
* **Bit-flip mutation** 
  * Given $x=\left(x_{1}, \ldots, x_{n}\right) \in\{0,1\}^{n},$ 
  * an index $k \in\{1, \ldots, n\}$ is picked uniformly at random.
  * $x^{\prime}$ is obtained by flipping bit $k$ in $x,$ formally
$$
x^{\prime}=\left(x_{1}, \ldots, x_{k-1}, 1-x_{k}, x_{k+1}, \ldots, x_{n}\right)
$$
* **Swap mutation** : not great for TSP
  * Given $x=\left(i_{1}, \ldots, i_{n}\right) \in \Pi_{n},$ 
  * two indices $k<\ell \in\{1, \ldots, n\}$ are picked
u. a. r. and 
  * $x^{\prime}$ is obtained by swapping the elements at these two places. 
  $$x^{\prime}=\left(i_{1}, \ldots, i_{k-1}, i_{\ell}, i_{k+1}, \ldots, i_{\ell-1}, i_{k}, i_{\ell+1}, \ldots, i_{n}\right)$$
* **Jump**  : better then swap for TSP 
  * Pick two indices $k<\ell$ 
  * let element at pos. $k$ jump to pos. $\ell,$ 
  * shift intermediate values to the left: 
  > (1,3,4,6,2,5)$\mapsto$(1,4,6,2,3,5) for $k=2, \ell=5$
* **2-OPT**: very good for TSP , see chapter TSP
  * Pick two edges
  * connect their endpoints "crossing over"

# Cross over Theory 


* **Order Crossover** $(\mathrm{OX}):$ Choose $k, \ell \in\{1, \ldots, n\},$ where $k<\ell,$ u. a. r. Take $\left(x_{k}, \ldots, x_{\ell}\right)$ from the first parent. Remaining positions, starting from $\ell+1,$ filled consecutively from second parent (also from $\ell+1$ ), skipping any occurrences of elements from $x_{k}, \ldots, x_{\ell}$. If an element of y is already present in x, then take the index of the position where it appears in x, move to y with the index and take that value.

* **Partially Matched Crossover (PMX)** Starts out as OX (take $\left(x_{k}, \ldots, x_{\ell}\right)$ from first parent). Remaining elements added from second parent by preserving absolute positions as far as possible. Elements $j$ from the second parent that cannot be put at the same position are filled with the elements that stand at the same position in $y$ as $j$ in $x$ (repeating the procedure until a valid element is found).

* **Cycle Crossover** $(\mathrm{CX})$ : tries to maintain many absolute positions of the first parent by identifying a "cycle" through the parents. Consider the two parents to define a mapping $f$ on the indices: $f\left(x_{i}\right):=y_{i}$ for $i \in\{1, \ldots, n\}$ 
Start by copying $x_{1}$ to $z_{1} .$ Then the element of $x$ that equals $y_{1}=f\left(x_{1}\right),$ say $x_{j},$ is copied to $z$ at the same position $j$. Proceed by finding the element of $x$ equaling $f\left(x_{j}\right)$ etc. until we hit an element that has already been copied to $z$. The remaining positions are filled with the missing elements according to the order in $y$.

# Best Crossover Operations

* **Partition Crossover (PX)**  PX can be implemented to run in time O(n).
  * Step 1: take the union of the tours given by the parents. Find edges common to both tours.
  * Find a cut through exactly two common edges. 
    * These edges are called cut edges. 
    * If impossible: crossover not feasible, return parents.
  * FIRST CHILD Given the two edges e and e' from the cut
    * start out at e
    * follow the tour from the first parent up to e'
    * then the tour from the second one. 
  * SECOND CHILD Other child is created in the opposite way.
    * start out at e'
    * follow the tour from the second parent up to e
    * then the tour from the first one. 

* **Generalized Partition Crossover (GPX)** GPX generalizes PX by considering possibly more than one cut:
    * Take out all common edges: the graph falls apart into connected components.
    * Determine for each component the shortest path through the component, again based on
all edges from the two parents.
    * Concatenation of these tours then gives rise to an offspring.

## mutations
"""

def bitflip_mutation(x):

  # check that all elements of x are 0s and 1s
  check = [element for element in x if not element in [0,1]]
  if len(check)>0:
    print ("the input string must have bits only ")
    return x
  else:
    k = random.choice(range(len(x)))
    current = x[k]
    if current == 0:
      flipped = 1
    else:
      flipped = 0
    x[k] = flipped
  return x

# test
x = [0,1,0,0,0,1,1,0,1]
z = bitflip_mutation(x)
z

def swap_mutation(x):
  # check if any element is repeated
  myset = set(x)
  n = len(x)
  idx = list(range(n))
  #print (myset)
  if len(list(myset)) != n:
    print (" there are repeated elements in the list given")
    return x
  else:
    sampling = random.choices(idx,k= 2)
    if sampling[0]<sampling[1]:
      k,l = sampling[0],sampling[1]
    else:
      k,l = sampling[1],sampling[0]
    child =x.copy()
    x[k],x[l] = x[l],x[k]
  return x

# test
x = [6,1,8,4,3,7,2,9]
z = swap_mutation(x)
z

def jump(x, print_statement = False, k = None, l = None):
  print ("")
  print ("boooooing")
  if k is None:
    random.seed(a=17)
    sampling = random.choices(idx,k = 2)
    if sampling[0]<sampling[1]:
      k,l = sampling[0],sampling[1]
    else:
      k,l = sampling[1],sampling[0]

  print ("k: %s; l:%s"%(k,l))
  print ("x: ",x)

  element = x.pop(k)
  x.insert(l,element)
  #print(x)
  return x

#jump
#example
sx = "1, 3, 4, 6, 2, 5"
#x = [int(item) for item in x if item.isdigit()]
x = [int(x) for x in sx.split(",")]

n = len(x)
child = [None] * n
d = np.row_stack([x,child])
df = pd.DataFrame(data=d,index = ["parent x", "child1"])
child = jump(x, print_statement = False, k= 1, l = 4)
df.loc['child1'] = child  # adding a row
df

"""## cross overs functions"""

def uniform_crossover(x,y,child, print_statement = False):
  random.seed(a=17)
  n = len(x)
  idx = [0,1]
  sampling = random.choices(idx,k= n)
  if print_statement== True:
    print (x)
    print (y)
    print (sampling)
  child = [x[i] if bit == 0 else y[i] for i,bit in enumerate(sampling) ]
  return child

#uniform crossover
#example
x = "(1, 2, 3, 5, 4, 6, 7, 8, 9)"
y = "(4, 5, 2, 1, 8, 7, 6, 9, 3)"
x = [ int(item) for item in x if item.isdigit()]
y = [ int(item) for item in y if item.isdigit()]
n = len(x)
child,child2 = [None] * n,[None] * n
d = np.row_stack([x,y,child,child2])
df = pd.DataFrame(data=d,index = ["parent x", "parent y", "child1", "child2"])
child = uniform_crossover(x,y,child, print_statement = False)
child2 = uniform_crossover(y,x,child, print_statement = False)
df.loc['child1'] = child  # adding a row
df.loc['child2'] = child2 # adding a row
df

# OX implementation
def OX_crossover(x,y,child, print_statement = False, k = None, l = None):
  print ("")
  print ("appling order crossover (OX)")
  if k is None:
    random.seed(a=17)
    sampling = random.choices(idx,k = 2)
    k,l = sampling[0], sampling[1]
    while k>=l:
      sampling = random.choices(idx,k = 2)
      k,l = sampling[0], sampling[1]

  print ("k: %s; l:%s"%(k,l))

  print ("x: ",x)
  print ("y: ",y)

  #take x_k to x_l from first parent
  child[(k-1):(l+0)] = x[(k-1):(l+0)]
  print (child)

  # find the indexes that are missing 
  missing_indexes = [index for index, element in enumerate(child) if element is None]
  if print_statement == True:
    print ("missing indexes in child" ,missing_indexes)

  # create a cycle for list missing_indexes
  index_cycle = cycle(missing_indexes)
  y_cycle = cycle(y)

  start = l
  if print_statement == True:
    print ("")
    print ("Start: ",start)
  skipped = dropwhile(lambda x: x != start, index_cycle)  # drop the values until x=index
  y_skipped = dropwhile(lambda x: x != y[start], y_cycle)  # drop the values until x=index

  sliced = islice(skipped, None, 4000)
  y_sliced = islice(y_skipped, None, 4000)

  while len(missing_indexes) >0:
    original_proposed_idx = next(sliced)
    proposed = next(y_sliced)
    if print_statement == True:
      print ("")
      print ("next proposed y value: %s " %(proposed))
    while proposed in child:
      if print_statement == True:
        print ("%s is already present" %proposed)
      proposed =next(y_sliced)
      if print_statement == True:
        print ("next proposed y value: %s " %(proposed))
    if print_statement == True:
      print ("proposed value accepted")
    child[original_proposed_idx] = proposed
    #print (child)
    missing_indexes = [index for index, element in enumerate(child) if element is None]
  return child

# PMX implementation
def PMX_crossover(x,y,child, print_statement = False, k = None, l = None):
  print ("")
  print ("appling Partially Matched Crossover (PMX)")
  if k is None:
    random.seed(a=17)
    sampling = random.choices(idx,k = 2)
    k,l = sampling[0], sampling[1]
    while k>=l:
      sampling = random.choices(idx,k = 2)
      k,l = sampling[0], sampling[1]

  print ("k: %s; l:%s"%(k,l))

  print ("x: ",x)
  print ("y: ",y)

  #take x_k to x_l from first parent
  child[(k-1):(l+0)] = x[(k-1):(l+0)]
  print (child)

  # find the indexes that are missing 
  missing_indexes = [index for index, element in enumerate(child) if element is None]
  if print_statement == True:
    print ("missing indexes in child" ,missing_indexes)

  # create a cycle for list missing_indexes
  index_cycle = cycle(missing_indexes)
  y_cycle = cycle(y)

  start = l
  if print_statement == True:
    print ("")
    print ("Start: ",start)
  skipped = dropwhile(lambda x: x != start, index_cycle)  # drop the values until x=index
  y_skipped = dropwhile(lambda x: x != y[start], y_cycle)  # drop the values until x=index

  sliced = islice(skipped, None, 400)
  y_sliced = islice(y_skipped, None, 400)

  while len(missing_indexes) >0:
    original_proposed_idx = next(sliced)
    proposed = next(y_sliced)
    if print_statement == True:
      print ("")
      print ("next proposed y value: %s " %(proposed))
    while proposed in child:
      if print_statement == True:
        print ("%s is already present" %proposed)
      
      #find proposed in x and take the index
      index_x = x.index(proposed)
      #take the correspondent index_x
      proposed = y[index_x]
      #proposed =next(y_sliced)
      if print_statement == True:
        print ("next proposed y value: %s " %(proposed))
    if print_statement == True:
      print ("proposed value accepted")
    child[original_proposed_idx] = proposed
    #print (child)
    missing_indexes = [index for index, element in enumerate(child) if element is None]
  return child

# CX implementation
def CX_crossover(x,y,child, print_statement = False):
  print ("")
  print ("appling Cycle Crossover (CX)")

  # start by copying child 
  #child = x.copy()
  #y_copy = y.copy()
  positions = []
  print ("x: ",x)
  print ("y: ",y)

  child_index = 0

  # take value from x
  value = x[child_index]

  while not value in child:  
    #assign value to child from x in the same position
    child[child_index] = value
    if print_statement == True:
      print (child_index, value)
    # find the value from y
    value = y[child_index]
    child_index = x.index(value) #find one index

  # find the indexes that are missing 
  missing_indexes = [index for index, element in enumerate(child) if element is None]

  for index in missing_indexes:
    child[index] = y[index]

  return child

def use_integers(list):
  return [int(x) for x in list]

def format_path(line,original):
  """
  lineformatted = format_line (line,original)
  """
  print (" in blue filler numbers (the ...)")
  lineformatted = [Fore.WHITE + Back.BLUE + str(char) + Style.RESET_ALL if not char in original
                  else str(char) for char in line ]
  lineformatted = " ".join(lineformatted)
  return lineformatted

"""## edges operators"""

def revert_order_in_edges(list_of_edges):
  """
  rev_list_of_edges = revert_order_in_edges(list_of_edges)
  (u,v)--->(v,u)
  """
  rev_list_of_edges = [(v,u) for (u,v) in list_of_edges]
  return rev_list_of_edges

def get_expanded_list (list_of_edges):
  """
  expanded_list = get_expanded_list (list_of_edges)
  [(u,v),(v,u)] <- [(u,v)]
  """
  rev_list_of_edges = revert_order_in_edges(list_of_edges)
  expanded_list = rev_list_of_edges+list_of_edges
  return expanded_list

def get_common_edges(list_1,list_2):
  """
  common_edges = get_common_edges(list_1,list_2)
  get common edges between two UNDIRECTED lists (meaning (2,3) == (3,2))
  """
  expanded_list_1 = get_expanded_list (list_1)
  common_edges = list(set(expanded_list_1).intersection(list_2))
  return common_edges

def sort_edges(list_of_edges):
  """
  sorted_list_of_edges = sort_edges(list_of_edges)

  first element of tuple < second element of tuple
  """
  sorted_list_of_edges = [(u,v) if u < v else (v,u) for (u,v) in list_of_edges]
  return sorted_list_of_edges

test_edges_1 = [(1,2),(3,4)]
test_edges_2 = [(1,2),(4,3)]

#rev_list_of_edges = revert_order_in_edges(test_edges_1)
#print (rev_list_of_edges)
#test_intersection = list(set(test_edges_1).intersection(test_edges_2))
#test_intersection
sort_edges(get_common_edges(test_edges_1,test_edges_2))

def mark_common_edges (edges_x,edges_y):
  """
  edges_x_formatted,edges_y_formatted = mark_common_edges (edges_x,edges_y)
  """
  print (" in green filler common numbers ")
  set_x = set(edges_x)
  intersection = set_x.intersection(edges_y)
  common_edges= list(intersection)
  print (common_edges)

  edges_x_formatted = [Fore.WHITE + Back.GREEN + str(edgetuple) + Style.RESET_ALL if edgetuple in edges_y
                  else str(edgetuple) for edgetuple in edges_x ]
  edges_x_formatted = " ".join(edges_x_formatted)

  edges_y_formatted = [Fore.WHITE + Back.GREEN + str(edgetuple) + Style.RESET_ALL if edgetuple in edges_x
                  else str(edgetuple) for edgetuple in edges_y ]
  edges_y_formatted = " ".join(edges_y_formatted)


  return edges_x_formatted,edges_y_formatted,common_edges

"""# Initialization

"""

x_format = Fore.BLUE+ Style.RESET_ALL
y_format = Fore.RED+ Style.RESET_ALL

#example
x = "(1, 2, 3, 5, 4, 6, 7, 8, 9)"
y = "(4, 5, 2, 1, 8, 7, 6, 9, 3)"
x = [ int(item) for item in x if item.isdigit()]
y = [ int(item) for item in y if item.isdigit()]

n = len(x)
idx = list(range(n))

# exercise
sx= "7;6;9;8;10;15;12;2;3;13;5;1;14;11;4"
sy= "10;14;9;4;3;11;1;6;8;15;2;12;7;5;13"

x = [int(x) for x in sx.split(";")]
y = [int(x) for x in sy.split(";")]

n = len(x)
idx = list(range(n))

d = np.row_stack([x,y])
d

df = pd.DataFrame(data=d,index = ["parent x", "parent y"])
df

"""# Execution"""

#OX Cross over
child,child2 = [None] * n,[None] * n
d = np.row_stack([x,y,child,child2])
df = pd.DataFrame(data=d,index = ["parent x", "parent y", "child1", "child2"])
child = OX_crossover(x,y,child,print_statement=False, k= 4, l=10)
child2 = OX_crossover(y,x,child2,print_statement=False, k= 4, l=10)
df.loc['child1'] = child  # adding a row
df.loc['child2'] = child2 # adding a row
df

#PMX crossover
child,child2 = [None] * n,[None] * n
d = np.row_stack([x,y,child,child2])
df = pd.DataFrame(data=d,index = ["parent x", "parent y", "child1", "child2"])
child = PMX_crossover(x,y,child,print_statement=False, k= 4, l=10)
child2 = PMX_crossover(y,x,child2,print_statement=False, k= 4, l=10)
df.loc['child1'] = child  # adding a row
df.loc['child2'] = child2 # adding a row
df

#CX crossover
child,child2 = [None] * n,[None] * n
d = np.row_stack([x,y,child,child2])
df = pd.DataFrame(data=d,index = ["parent x", "parent y", "child1", "child2"])
child = CX_crossover(x,y,child, print_statement = False)
child2 = CX_crossover(y,x,child2, print_statement = False)
df.loc['child1'] = child  # adding a row
df.loc['child2'] = child2 # adding a row
df

"""# TSP with 2OPT

##Import
"""

# geografy stuff
!pip install geonamescache

#create random coordinates for the stations 
from random import uniform
#from random import random # call it as random.random()
from random import randrange as rd
from math import pi, cos, sin
import random

#path stuff
import matplotlib.pyplot as plt
from matplotlib.path import Path
import matplotlib.patches as patches

# geografy stuff
import geonamescache
import math

"""##new print path, to be finished"""

def plot_stations(xs, ys,stations_coord,Dlab= 10 , Slab = 10, name = 0):
  # plot
  if name != 0:
    plotlabel = "%s" %name
    plt.title (plotlabel , size=20)
  #fig = plt.figure(figsize=(10,10))
  #ax = plt.axes()
  s = max (max(xs),max(ys))
  m = min (min(xs),min(ys))
  
  ax.set_xticks(np.arange(m-10,+s+10,s/10))
  ax.set_yticks(np.arange(m-10,+s+10,s/10))

  #cool one liner!
  #plt.scatter(*zip(*stations_coord))

  #annotations
  for i,txt in enumerate(labels_stations):

    if this_type == "ex_circular":
      if i != len(labels_stations)-1:
        dx,dy = get_labels_distances(xs[i],ys[i],d=Dlab)
        plt.annotate(txt, 
                    (xs[i],ys[i]),
                      textcoords="offset points", # how to position the text
                      xytext=(dx,dy), # distance from text to points (x,y)
                      ha='center', # horizontal alignment can be left, right or center 
                      size = Slab
                      )
    else:
      dx,dy = 5,5
      plt.annotate(txt, 
                    (xs[i],ys[i]),
                    textcoords="offset points", # how to position the text
                    xytext=(dx,dy), # distance from text to points (x,y)
                    size = Slab
                  )
  plt.scatter(xs, ys)
  plt.grid()
  plt.show()

def print_path_new(current_path,stations_coord,test,h=30,l=30, Dlab = 10, Slab = 20):
  if test != None: 
    verts = []
    #best_path = optimized_paths[len(optimized_paths)-1]
    best_path = current_path
    for st in best_path: # take the best path and plot
      verts.append(stations_coord[st])

    codes = [Path.MOVETO]*len(verts)
    path = Path(verts, codes)

    fig = plt.figure(figsize=(h,l))
    ax = plt.axes()
    plt.grid()
    #fig, ax = plt.subplots()
    
    patch = patches.PathPatch(path, facecolor='none', lw=2)
    ax.add_patch(patch)

    xs, ys = zip(*verts)

    plot_stations(xs, ys,stations_coord,Dlab= 10 , Slab = 10)

"""### print multiple paths"""

def print_multiplepath(x,y,stations_coord,h=20,l=20, Dlab = 10, Slab = 20, name = 0):
  # plot

   
    verts_x = []
    for st in x: # take the best path and plot
      try:
        verts_x.append(stations_coord[st])
      except Exception as e: 
        print(e)
    codes_x = [Path.MOVETO]*len(verts_x)
    path_x = Path(verts_x, codes_x)

    verts_y = []
    for st in y: # take the best path and plot
      try:
        verts_y.append(stations_coord[st])
      except Exception as e: 
        print(e)
    codes_y = [Path.MOVETO]*len(verts_y)
    path_y = Path(verts_y, codes_y)

    fig = plt.figure(figsize=(h,l))
    #ax1 = fig.add_subplot(111)
    ax1 = plt.axes()
    plt.grid()
    #fig, ax = plt.subplots()
    
    patch_x = patches.PathPatch(path_x, facecolor='none', lw=2)
    ax1.add_patch(patch_x)
    x_xs, x_ys = zip(*verts_x)

    patch_y = patches.PathPatch(path_y, facecolor='none', lw=2)
    ax1.add_patch(patch_y)
    y_xs, y_ys = zip(*verts_y)

    # settings of plto
    ax1.plot(x_xs, x_ys, lw=4, color='blue', ms=10,alpha = 0.3, label='x')
    ax1.plot(y_xs, y_ys, lw=4, color='red', ms=10,alpha = 0.5, label='y')

    #plot ticks
    ax1.set_xticks(np.arange(min(x_xs)-1, max(x_xs)+1,max(x_xs)/10))
    ax1.set_yticks(np.arange(min(x_ys)-1, max(x_ys)+1,max(x_ys)/10))

    
    for i,txt in enumerate(labels_stations):
      if i != len(labels_stations)-1:
        dx,dy = get_labels_distances(x_xs[i],x_ys[i],d=Dlab)
        plt.annotate(txt, 
                    (x_xs[i], x_ys[i]),
                    textcoords="offset points", # how to position the text
                      xytext=(dx,dy), # distance from text to points (x,y)
                      ha='center', # horizontal alignment can be left, right or center 
                    size = Slab
                    )
    #plot the nodes
    ax1.scatter(x_xs,x_ys, s=10, c='b', marker="s", alpha = 0.3)
    ax1.scatter(y_xs,y_ys, s=10, c='r', marker="o", alpha = 0.5)
    
    #plot legend and title
    plt.legend(loc='upper left');
    if name != 0:
      plotlabel = "%s" %name
      plt.title (plotlabel , size=20)


    plt.show()

"""## print one path"""

def print_path(current_path,stations_coord,test,h=30,l=30, Dlab = 10, Slab = 20, name = 0):
  # plot

  if test != None: 
    verts = []
    #best_path = optimized_paths[len(optimized_paths)-1]
    best_path = current_path
    for st in best_path: # take the best path and plot
      try:
        verts.append(stations_coord[st])
      except Exception as e: 
        print(e)


    codes = [Path.MOVETO]*len(verts)

    #print (best_path)
    #print (len(verts))
    #print ((len(codes)))
    path = Path(verts, codes)

    fig = plt.figure(figsize=(h,l))
    ax = plt.axes()
    plt.grid()
    #fig, ax = plt.subplots()
    
    patch = patches.PathPatch(path, facecolor='none', lw=2)
    ax.add_patch(patch)

    xs, ys = zip(*verts)

    # settings of plto
    ax.plot(xs, ys, lw=2, color='red', ms=10)
    x_axis = np.arange(min(xs)-1, max(xs)+1,max(xs)/10)
    ax.set_xticks(x_axis)
    xlabels = ["%.2f"%x for x in x_axis]
    ax.set_xticklabels(xlabels, rotation=90)
    ax.set_yticks(np.arange(min(ys)-1, max(ys)+1,max(ys)/10))

    if this_type == ("ex_circular" or "circular"):
      for i,txt in enumerate(labels_stations):
        if i < len(current_path):
          dx,dy = get_labels_distances(xs[i],ys[i],d=Dlab)
          plt.annotate(txt, 
                      (xs[i], ys[i]),
                      textcoords="offset points", # how to position the text
                        xytext=(dx,dy), # distance from text to points (x,y)
                        ha='center', # horizontal alignment can be left, right or center 
                      size = Slab
                      )
    else: 
      for i,txt in enumerate(labels_stations):
        if i < len(current_path):
          plt.annotate(txt, 
                      (xs[i], ys[i]),
                      size = Slab
                      )
          
    plt.scatter(xs, ys)

    #ax.set_xlim(-0.1, 200)
    #ax.set_ylim(-0.1, 200)
    if name != 0:
      plotlabel = "%s" %name
      plt.title (plotlabel , size=20)
    plt.show()

def get_labels_distances(x_s,y_s,d):
  x_lab, y_lab =0,0
  if (x_s > x_central_point) and (y_s > y_central_point):
    x_lab, y_lab = x_s+d,y_s+d
  elif (x_s > x_central_point) and (y_s < y_central_point):
    x_lab, y_lab = x_s+d,y_s-d
  elif (x_s < x_central_point) and (y_s < y_central_point):
    x_lab, y_lab = x_s-d,y_s-d
  elif (x_s < x_central_point) and (y_s > y_central_point):
    x_lab, y_lab = x_s-d,y_s+d
  elif (x_s == x_central_point) and (y_s > y_central_point):
    x_lab, y_lab = x_s,y_s+d
  elif (x_s == x_central_point) and (y_s < y_central_point):
    x_lab, y_lab = x_s,y_s-d
  elif (x_s > x_central_point) and (y_s == y_central_point):
    x_lab, y_lab = x_s+d,y_s
  elif (x_s < x_central_point) and (y_s == y_central_point):
    x_lab, y_lab = x_s-d,y_s
  return x_lab, y_lab

"""## creates stations coordinates"""

## exercise
# stations around a central point
def ex_point(h,k,i,n, r):
  rad = 2 * pi *r
  internal = i*rad/n
  #print (h,k,internal)
  #theta = random.random() * 2 * pi
  x = h + cos(i*rad/n)
  y = k + sin(i*rad/n)
  return x,y


def ex_circular_disposition(n,r):
  stations_coord = []
  i = 1
  while len(stations_coord) < (n+1):
    a, b =  ex_point(x_central_point,y_central_point,i,n,r)
    stations_coord.append((a,b))
    #print (i,a,b)
    i += 1
  return stations_coord

# wrapping up
def create_station_position(n, r,mytype = "circular"):
  """
  stations_coord = create_station_position(n,r,  mytype = "circular")
  types: "circular","ex_circular","random", "structured"
  """
  if mytype == "circular":
    stations_coord = circular_disposition(n)
  elif mytype == "ex_circular":
    stations_coord = ex_circular_disposition(n,r)
  elif mytype == "random":
    stations_coord = random_disposition(n)
  else: 
    stations_coord = structured_disposition(n)
  return stations_coord

##random position of stations
def random_disposition(n):
  stations_coord = []
  #stations_coord.append((0,0)) #dummy.. not needed? 
  while len(stations_coord) < (n+1):
    x, y =  int(random.uniform(0,300)), int(random.uniform(0,200))
    stations_coord.append((x,y))
  return stations_coord

##more structured disposistion of stations
def structured_disposition(n):
  stations_coord = []
  x_list = []
  y_list = []
  mindist = 20
  maxdist = 150
  maxc=int(np.sqrt((maxdist**2)/2))
  while len(stations_coord) < (n+1):
          #x_delta=rd(1,maxc,1) 
          #y_delta=rd(1,maxc,1) 
          x_delta, y_delta =  int(random.uniform(0,maxc)), int(random.uniform(0,maxc))
          distance_from_central_point = np.sqrt(x_delta**2 + y_delta**2)
          if distance_from_central_point > mindist: 
              x=x_central_point+ x_delta
              y=y_central_point+ y_delta 
              new_station=(x,y)
              if new_station not in stations_coord: #avoid to create red point with the same coordinates
                  stations_coord.append(new_station)
                  x_list.append(x) 
                  y_list.append(y)
  return stations_coord

# stations around a central point
def point(h, k, r,randstring):
  #random.seed(a = 42)
  myrand = randstring.pop(0)/100
  theta = myrand * 2 * pi
  #theta = random.random() * 2 * pi
  x = h + cos(theta) * r
  y = k + sin(theta) * r
  return (x,y)


def circular_disposition(n):
  stations_coord = []
  while len(stations_coord) < (n+1):
    randstring = random.choices(range(0,100),k = n+1)
    x, y =  point(x_central_point,y_central_point,r,randstring)
    stations_coord.append((x,y))
  return stations_coord

# https://pypi.org/project/geonamescache/
city_list = list()
if len(city_list) == 0: 
  gc = geonamescache.GeonamesCache()
  cities = gc.get_cities()
  cities_df = pd.DataFrame(data=cities)
  df_t = cities_df.T
  df_t.head()
  city_list = df_t['name'].tolist()

city_list[:10]

# create stations labels 
def name_stations(n, geografic_names = False, only_numbers = False, print_statement = False ,start_from_one = False):
  labels_stations = []
  if only_numbers == True:
    for i in range(n+1):
      if print_statement == True: 
        print ( "%i : %s" %(i,stations_coord[i]))
      if start_from_one == False:
        labels_stations.append("%i" %(i))
      else:
        labels_stations.append("%i" %(i+1))
  else:
    if geografic_names == False:
      for i in range(n+1):
        if print_statement == True: 
          print ( "Station %i %s" %(i,stations_coord[i]))
        labels_stations.append("Station %i %s" %(i,stations_coord[i]))
    else:
      sampling = random.choices(city_list,k =n)
      for i,name in enumerate(sampling):
        if print_statement == True: 
          print ( "Station %s %s" %(name,stations_coord[i]))
        labels_stations.append("Station %s %s" %(name,stations_coord[i]))
  return labels_stations

"""## euclidean distance"""

# define target function
#def f(u,T):
  #target = np.exp(-u/T)
  #return target

# cost function, simple euclidean norm between station X = S[idx_st2] and station Y = S[idx_st1]
def euclidean_distance(indx,indy,test = None):
    ax,ay = stations_coord[indx]
    bx,by = stations_coord[indy]
    # print (ax,ay)
    # print (bx,by)

    #XY_cost = np.linalg.norm(A-B)
    XY_cost = math.sqrt((ax-bx)**2+(ay-by)**2)
    if test != None:
      print ("cost from %i to %i : %.2f "%(indx,indy,XY_cost))
    return XY_cost    

# total path cost
def Euclidean_path_cost(path,test = None):
  cost = 0
  weights_list = []
  for i in range(1,len(path)):
    indx = path[i-1] #previous station
    indy = path[i] # next station
    #print ("indexes: %i %i "% (indx,indy))
    XY_cost = euclidean_distance(indx,indy)
    weights_list.append(XY_cost)
    if test != None:
      print ("%i, between %i and %i" %(XY_cost,indx,indy))
    cost = cost + XY_cost
  return cost,weights_list

"""## 2-OPT functions"""

def print_all_costs(all_final_costs):
  y = all_final_costs
  x = list(range(len(all_final_costs)))

  fig = plt.figure(figsize=(15,10))
  ax = plt.axes()
  plt.grid()
  plt.loglog(x, y, 'ro')

  plt.subplot(211)
  plt.plot(x, y, 'ro')
  plt.axis([min(x)-5, max(x)+5, min(y)-5, max(y)+5])

  plt.subplot(212)
  plt.grid()
  plt.loglog(x, y, 'ro')
  # with errorbars: clip non-positive values
  ax = plt.subplot(212)
  ax.set_xscale("log", nonposx='clip')
  ax.set_yscale("log", nonposy='clip')


  plt.show()

def take_last_node_connection(listofedges):
  last_element =  (listofedges[-1][1])
  return last_element

def find_next_edge(last_element,new_edges_proposed):
  next_edge = None
  visited_edge = []
  while len(visited_edge) < len(new_edges_proposed):
    for edge in new_edges_proposed:
      u,v = edge
      if u == last_element:
        next_edge = [(u,v)]
        return next_edge
      elif v == last_element:
        next_edge = [(v,u)]
        return next_edge
      else:
        visited_edge.append(edge)
        #print (" looking for element : ",last_element)
        #print ("not found in edge: ",edge)
        continue

def create_edges(initial_path,weights_list):
  """
  edges_list,dict_weights =  create_edges(initial_path,weights_list)
  """
  dict_weights = dict()
  edges_list = []
  for i in range(len(initial_path)-1):
    u,v = initial_path[i],initial_path[i+1]
    w = weights_list[i]
    dict_weights[(u,v)] = w
    dict_weights[(v,u)] = w
    edges_list.append((u,v))
  return edges_list,dict_weights

def element_is_extreme(element,mylist):
  if element == mylist[0] or element == mylist[-1]:
    return True

def get_new_edge_list(edges_list,initial_path ):
  l = len(edges_list)
  my_idx_list = list(range(l))
  idx_chosen = random.sample(my_idx_list,2)
  while element_is_extreme(idx_chosen[0],my_idx_list) and element_is_extreme(idx_chosen[0],my_idx_list):
    idx_chosen = random.sample(my_idx_list,2)

  edges_chosen = [edges_list[idx] for idx in idx_chosen ]
  edges_chosen = sorted(edges_chosen)

  #print ("initial random path",initial_path)
  #print ("initial edges_list",edges_list)
  #print (idx_chosen)
  #print (edges_chosen)

  new_edges_list = edges_list.copy()
  for i in idx_chosen:
    new_edges_list[i] = "removed"
  #print ("new edges_list",new_edges_list)
  return new_edges_list,idx_chosen,edges_chosen

# MAIN "OPT"
def two_OPT(weights_list,initial_path, best_result,counter,all_final_costs, print_statement = False):
  """
  best_path, best_result = two_OPT(weights_list,initial_path, best_result, counter,all_final_costs, print_statement = False)
  """
  #print ("")
  if counter % (MAX_RUN/10) == 0:
    print ("RUN:",counter)
  edges_list,dict_weights = create_edges(initial_path,weights_list)
  new_edges_list,idx_chosen,edges_chosen = get_new_edge_list(edges_list,initial_path )

  if print_statement == True: 
   print (edges_list)
   print (new_edges_list)

  #slice tour and reverse part of it
  if print_statement == True: 
    print ("slicing")
  sidx = sorted(idx_chosen)
  slice_L = edges_list[:sidx[0]]
  slice_C = edges_list[sidx[0]+1:sidx[1]]
  slice_R = edges_list[sidx[1]+1:]
  slice_to_reverse = slice_R + slice_L
  reversed = slice_to_reverse[::-1]
  reversed = [ (v,u) for (u,v) in reversed]
  if print_statement == True: 
    print (slice_L,"/", slice_C,"/",slice_R)
    print (slice_to_reverse)

  # new edges proposed
  if print_statement == True: 
    print ("new edges")
  i_l, i_l1 = edges_chosen[0]
  i_k, i_k1 = edges_chosen[1]
  new_edges_proposed = [(i_l,i_k),(i_k1,i_l1)]
  #print ("new_edges_proposed: ",new_edges_proposed)

  # combine it all together
  final_edges_list = reversed

  last_element = take_last_node_connection(final_edges_list)
  if print_statement == True: 
    print ("final_edges_list: ",final_edges_list)
    print ("LAST: ",last_element)
  next_edge = find_next_edge(last_element,new_edges_proposed)
  final_edges_list += next_edge

  final_edges_list += slice_C 

  last_element = take_last_node_connection(final_edges_list)
  next_edge = find_next_edge(last_element,new_edges_proposed)
  final_edges_list += next_edge
  #print (final_edges_list)
  final_path = [u for (u,v) in final_edges_list] 
  final_path.append(final_path[0])

  #print
  final_cost, weights_list = Euclidean_path_cost(final_path)
  all_final_costs.append(final_cost)

  # if 
  if print_statement == True: 
    print ("")
    print ("edges ")
    print (edges_list)
    print (new_edges_list)
    print (final_edges_list)

    print ("")
    print ("paths ")
    print ("initial random path",initial_path)
    print ("final path",final_path)
    print ("final cost : %.2f"%final_cost)

    #print optimal solution
    print_path(final_path,stations_coord,"always")
  
  if final_cost < best_result:
    best_result = final_cost
    best_path = final_path

  else: 
    best_path = initial_path
  counter +=1
  return best_path, best_result, counter,all_final_costs

def print_best_solution(initial_path,initial_cost,final_path,final_cost, H= 10, L= 10, DLAB = 10, SLAB = 10):
  print ("initial cost : %.2f"%initial_cost)
  print ("final cost : %.2f"%final_cost)

  print ("")
  print ("paths ")
  print ("initial random path",initial_path)
  print ("final path",final_path)

  #print optimal solution
  print_path(final_path,stations_coord,"always", h = H, l = L, Dlab = DLAB, Slab = SLAB )

"""## initialize"""

x_central_point,y_central_point  = 0, 0
r = 1

# create station positions
n = 100
# randomly initialized
this_type = "random"  #(ex_circular, circular, random, structured)

stations_coord = create_station_position(n,r, mytype = this_type)
stations_coord = stations_coord#[:-1]#droppo il dummy
#print (stations_coord)
# labelfor all the stations
labels_stations = name_stations(n, geografic_names = False, only_numbers = True)
#print (labels_stations)

#stations_coord

# plot
xs = [float(point[0]) for point in stations_coord] 
ys = [float(point[1]) for point in stations_coord]



fig = plt.figure(figsize=(10,10))
ax = plt.axes()
s = max (max(xs),max(ys))
m = min (min(xs),min(ys))
SIZE = 10
plt.grid()

#cool one liner!
#plt.scatter(*zip(*stations_coord))
for i,txt in enumerate(labels_stations):

  if this_type == "ex_circular":
    if i != len(labels_stations)-1:
      dx,dy = get_labels_distances(xs[i],ys[i],d=10)
      ax.set_xticks(np.arange(m-10,+s+10,s/10))
      ax.set_yticks(np.arange(m-10,+s+10,s/10))
      plt.annotate(txt, 
                  (xs[i],ys[i]),
                    textcoords="offset points", # how to position the text
                    xytext=(dx,dy), # distance from text to points (x,y)
                    ha='center', # horizontal alignment can be left, right or center 
                    size = SIZE
                    )
  elif this_type == ("circular"):
    ax.set_xticks(np.arange(m-10,+s+10,s/10))
    ax.set_yticks(np.arange(m-10,+s+10,s/10))
    plt.annotate(txt, 
                (xs[i],ys[i]),
                  size = SIZE
                  )
  else:
    ax.set_xticks(np.arange(m-10,+s+10,s/10))
    ax.set_yticks(np.arange(m-10,+s+10,s/10))
    dx,dy = 5,5
    plt.annotate(txt, 
                  (xs[i],ys[i]),
                  textcoords="offset points", # how to position the text
                  xytext=(dx,dy), # distance from text to points (x,y)
                  size = SIZE
                )
plt.scatter(xs, ys)
plt.show()

# check if initialization is correct

#Initialise with a random permutation of stations
np.random.seed(seed = 42)
initial_path = np.random.permutation(len(stations_coord)-1) 
initial_path = [x for x in initial_path]

# the route must end where it started
first_element = initial_path[0]
initial_path.append(first_element)

print ("initial random path",initial_path)
initial_cost, weights_list = Euclidean_path_cost(initial_path)
#print ("costs: ",weights_list)
print ("initial cost : %.2f"%initial_cost)

#print initial solution
print_path(initial_path,stations_coord,"always",h=10,l=10, Dlab = 5, Slab = 10)

"""## run """

path = initial_path
cost = initial_cost
all_final_costs = []
counter = 0
MAX_RUN = 1000
while counter < MAX_RUN :
  path, cost, counter,all_final_costs = two_OPT(weights_list, path, cost, counter,all_final_costs, False)

final_path,final_cost = path, cost

print_best_solution(initial_path,initial_cost,final_path,final_cost, H = 10, L = 10, DLAB = 10 , SLAB = 10)

min(all_final_costs)

print_all_costs(all_final_costs)

"""## run again """

path,cost = final_path,final_cost
all_final_costs = []
counter = 0
MAX_RUN = 4000
while counter < MAX_RUN :
  path, cost, counter,all_final_costs = two_OPT(weights_list , path, cost, counter,all_final_costs, print_statement = False)

final_path,final_cost = path, cost

print_best_solution(initial_path,initial_cost,final_path,final_cost, H = 10, L = 10)

print_all_costs(all_final_costs)

"""# TSP with GPX

## functions

## main
"""

